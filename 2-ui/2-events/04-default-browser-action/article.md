# Действия браузера по умолчанию

Многие события автоматически влекут за собой действие браузера.

Например:

- Клик по ссылке инициирует переход на новый URL.
- Нажатие на кнопку «отправить» в форме – отсылку ее на сервер.
- Двойной клик на тексте – инициирует его выделение.

Если мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно. К счастью, его можно отменить.

## Отмена действия браузера

Есть два способа отменить действие браузера:

- Основной способ – это воспользоваться объектом события (event object). Для отмены действия браузера существует стандартный метод `event.preventDefault()`.
- Если же обработчик назначен через `on<событие>` (не через `addEventListener`), то можно просто вернуть `false` из обработчика.

В следующем примере при клике по ссылке переход не произойдет:

```html autorun height=60 no-beautify
<a href="/" onclick="return false">Нажми здесь</a>
или
<a href="/" onclick="event.preventDefault()">здесь</a>
```

```warn header="Возвращать `true` не нужно"
Обычно значение, которое возвращает обработчик события, игнорируется.

Единственное исключение – это `return false` из обработчика, назначенного через `on<событие>`.

В других случаях return не нужен, он никак не обрабатываются.
```

### Пример: меню

Рассмотрим меню для сайта, например:

```html
<ul id="menu" class="menu">
  <li><a href="/html">HTML</a></li>
  <li><a href="/javascript">JavaScript</a></li>
  <li><a href="/css">CSS</a></li>
</ul>
```

Данный пример при помощи CSS может выводиться так:

[iframe height=70 src="menu" link edit]

HTML-разметка сделана так, что все элементы меню являются не кнопками, а ссылками, то есть тегами `<a>`. В этом подходе есть некоторые преимущества, например:

- Некоторые посетители очень любят сочетание «правый клик – открыть в новом окне». Если мы будем использовать `<button>` или `<span>`, то данное сочетание работать не будет.
- Поисковые движки переходят по ссылкам `<a href="...">` при индексации.

Поэтому в разметке мы используем `<a>`. Но нам необходимо обрабатывать клики в JavaScript, а стандартное действие браузера (переход по ссылке) - отменить.

Например, вот так:

```js
menu.onclick = function(event) {
  if (event.target.nodeName != 'A') return;

  let href = event.target.getAttribute('href');
  alert( href ); // может быть подгрузка с сервера, генерация интерфейса и т.п.

*!*
  return false; // отменить переход по url
*/!*
};
```

Если мы опустим `return false`, то после выполнения обработчика события браузер выполнит "действие по умолчанию" - переход по адресу из `href`.

Так как мы применили делегирование, то меню может увеличиваться, можно добавить вложенные списки ul/li, стилизовать их при помощи CSS – обработчик не потребует изменений.


## Отмена последующих событий

Некоторые события естественным образом вытекают друг из друга. Если мы отменим первое событие, то последующие не выполнятся.

Например, событие `mousedown` для поля `<input>` приводит к фокусировке на нём и запускает событие `focus`. Если мы отменим событие `mousedown`, то фокусирования не произойдёт.

В следующем примере попробуйте нажать на первом `<input>` -- происходит событие `focus`. Это нормально.

Но если вы нажимаете по второму элементу, то события `focus` не будет.

```html run autorun
<input value="Фокус работает" onfocus="this.value=''">
<input *!*onmousedown="return false"*/!* onfocus="this.value=''" value="Кликни меня">
```

Это потому, что отменено стандартное действие `mousedown`. Но фокусировка на элементе всё ещё возможна, если мы будем использовать другой способ. Например, нажатием клавиши `key:Tab` можно перейти от первого поля ввода ко второму. Но только не через нажатие мышью по элементу, это больше не работает.

## Опция "passive" для обработчика

Необязательная опция `passive: true` для `addEventListener` сигнализирует браузеру, что обработчик не собирается выполнять `preventDefault()`.

Почему это может быть полезно?

Есть некоторые события, как `touchmove` на мобильных устройствах (когда пользователь перемещает палец по экрану), по умолчанию запускается скроллинг, но мы можем отменить это действие, используя `preventDefault()` в обработчике.

Поэтому, когда браузер обнаружит такое событие, он должен для начала обработать все обработчики и после, если `preventDefault` не вызывается нигде, он может продолжить скроллинг. Это может вызвать ненужные задержки и "дрожание" в пользовательском интерфейсе.

Опция `passive: true` сообщает браузеру, что обработчик не собирается отменять скроллинг. Тогда браузер запускает скроллинг немедленно, обеспечивая максимально плавный интерфейс, параллельно обрабатывая событие.

Для некоторых браузеров (Firefox, Chrome) опция `passive` по умолчанию включена `true` для таких событий, как `touchstart` и `touchmove`.


## event.defaultPrevented

Свойство `event.defaultPrevented` установлено в `true`, если действие по умолчанию было предотвращено и `false` если нет.

Интересное применение свойства.

Помните, в главе <info:bubbling-and-capturing> мы говорили о `event.stopPropagation()` и упоминали, что останавливать "всплытие" - плохо?

Иногда мы можем использовапть `event.defaultPrevented`.

Давайте посмотрим практический пример, где остановка всплытия кажется обязательной, но на самом деле мы можем обойтись без него.

По умолчанию браузер при событии `contextmenu` (клик на правую кнопку мыши) показывает контекстное меню со стандартными опциями. Мы можем отменить событие по умолчанию и показать своё меню, как здесь:

```html autorun height=50 no-beautify run
<button>ПКМ для вызова контекстного меню браузера</button>

<button *!*oncontextmenu="alert('Рисуем наше меню'); return false"*/!*>
  ПКМ для вызова нашего контекстного меню
</button>
```

Теперь предположим, что мы хотим реализовать собственное контекстное меню для всего документа с нашими опциями. И внутри документа мы можем иметь другие элементы, у которых может быть своё контекстное меню:

```html autorun height=80 no-beautify run
<p>ПКМ для контекстного меню документа</p>
<button id="elem">ПКМ для контекстного меню кнопки</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>
```

Проблема заключается в том, что когда мы кликаем по элементу `elem`, то мы получаем два меню: контекстное меню для кнопки и (событие всплывает вверх) контекстное меню для документа.

Как это исправить? Одним из решений будет: "Мы полностью обрабатываем событие в обработчике кнопки, давайте остановим всплытие" и использовать `event.stopPropagation()`:

```html autorun height=80 no-beautify run
<p>ПКМ для меню документа</p>
<button id="elem">ПКМ для меню кнопки(добавлен event.stopPropagation)</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
*!*
    event.stopPropagation();
*/!*
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>
```

Теперь контекстное меню для кнопки работает как задумано. Но цена слишком высока. Мы навсегда запретили доступ к контекстному меню для любого внешнего кода, включая счётчики, которые собирают статистику и так далее. Это слегка неразумно.

Альтернативным решением было бы проверить в обработчике `document`, было ли отменено действие по умолчанию? Если да, тогда событие обрабатывается и нам не нужно на него реагировать.


```html autorun height=80 no-beautify run
<p>ПКМ для меню документа (добавлен event.defaultPrevented)</p>
<button id="elem">ПКМ для меню кнопки</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = function(event) {
*!*
    if (event.defaultPrevented) return;
*/!*

    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>
```

Сейчас всё работает правильно. Если у нас есть вложенные элементы и каждый из них имеет контекстное меню, то код также будет работать. Просто убедитесь, что проверяете `event.defaultPrevented` для каждого обработчика `contextmenu`.

```smart header="event.stopPropagation() и event.preventDefault()"
Как мы можем видеть `event.stopPropagation()` и `event.preventDefault()` (также известный как `return false`)  - это две разные функции. Они никак не связаны друг с другом.
```

```smart header="Архитектура вложенных контекстных меню"
Есть также несколько альтернативных путей, чтобы реализовать вложенные контекстные меню. Одним из них является специальный глобальный объект с методом, который обрабатывает `document.oncontextmenu` и также методы, позволяющие хранить в нем различные "низкоуровневые" обработчики.

Объект будет перехватывать любой клик правой кнопкой мыши, просматривать сохранённые обработчики и запускать соответствующий.

Но затем каждый фрагмент кода, которому требуется контекстное меню, должен знать об этом объекте и использовать его, вместо собственного обработчика `contextmenu`.
```

## Итого

Действий браузера по умолчанию достаточно много:

- `mousedown` -- нажатие кнопкой мыши в то время как курсор находится на тексте начинает его выделение.
- `click` на `<input type="checkbox">` --  ставит или убирает галочку в `input`.
- `submit` -- при нажатии на `<input type="submit">` или при нажатии клавиши `key:Enter` в форме данные отправляются на сервер.
- `wheel` -- движение колёсика мыши инициирует прокрутку.
- `keydown` -- при нажатии клавиши в поле ввода появляется символ.
- `contextmenu` -- при правом клике показывается контекстное меню браузера.
- ...и многие другие...

Все эти действия можно отменить, если мы хотим обработать событие исключительно при помощи JavaScript.

Чтобы отменить действие браузера по умолчанию, то используйте `event.preventDefault()` или  `return false`. Второй метод работает только если обработчик назначен через `on<событие>`.

Опция `passive: true` для `addEventListener` сообщает браузеру, что действие по умолчанию не будет отменено. Это очень полезно для некоторых событий на мобильных устройствах, такиз как `touchstart` и `touchmove`, чтобы сообщить браузеру, что он не должен ожидать выполнения всех обработчиков, а сразу приступил к выполнению дествия по умолчанию, например, скроллинг.

Если событие по умолчанию отменено, то значение `event.defaultPrevented` становится `true`, иначе `false`.

```warn header="Сохраняйте семантику, не злоупотребляйте"
Технически, отменяя действия браузера по умолчанию и добавляя JavaScript мы можем настроить поведение любого элемента. Например, мы можем заставить ссылку `<a>` работать как кнопку, а кнопку `<button>` вести себя как ссылку (перенаправлять на другой URL).

Но нам следует сохранять семантическое значение HTML элементов. Например, не кнопки, а тэг `<a>` должен применяться для переходов по ссылкам.

Помимо того, что это "просто хорошая вещь", это делает ваш HTML лучше с точки зрения доступности.

Также, если мы рассматриваем пример с тэгом `<a>`, тогда обратите внимание: браузер предоставляет возможность открывать ссылки в новом окне (кликая правой кнопкой мыши или используя другие возможности). И пользователям это нравится. Но если мы заменим ссылку кнопкой и стилизуем её как ссылку, используя CSS, тогда специфичные функции браузера для тэга `<a>` всё равно работать не будут.
```
