# Стили и классы

До того, как начнете изучать способы работы со стилями и классами в JavaScript, есть одно важно правило. Надеемся, это достаточно очевидно, но мы все равно должны об этом упомянуть.

Как правило, существует два способа задания стилей для элемента:

1. Создать класс в CSS и использовать его: `<div class="...">`
2. Писать стили непосредственно в атрибуте `style`: `<div style="...">`.

Использование CSS -- это всегда предпочтительный вариант и не только для HTML, но и для JavaScript.

Мы должны манипулировать свойством `style` только в том случае, если классы "не могут справиться".

Например, использование `style` является приемлемым, если мы вычисляем координаты элемента динамически и хотим установить их из JavaScript, подобно этому:

```js
let top = /* сложные расчёты */;
let left = /* сложные расчёты */;
elem.style.left = left; // например, '123px'
elem.style.top = top; // например, '456px'
```

В других случаях, например, сделать текст красным, добавить значок фона -- необходимо описать это в CSS, а затем применить класс. Это более гибкий и легкий в обслуживании инструмент.

## className и classList

Изменение класса является одним из наиболее часто используемых действий в JavaScript.

Раньше в JavaScript существовало ограничение: зарезервированное слово типа `"class"` не могло быть свойством объекта. Это ограничение сейчас не существует, но в то время было невозможно иметь `"class"` свойство, как `elem.class`.

Поэтому для классов было введено схожее свойство `"className"`: `elem.className` соответствует атрибуту `"class"`.

Например:

```html run
<body class="main page">
  <script>
    alert(document.body.className); // main page
  </script>
</body>
```

Если мы присваиваем что-то `elem.className`, то это заменяет всю строку с классами. Иногда это то, что нам нужно, но часто мы хотим добавить/удалить один класс.

Для этого есть другое свойство: `elem.classList`.

`elem.classList` -- это специальный объект с методами `add/remove/toggle` классов.

Например:

```html run
<body class="main page">
  <script>
*!*
    // добавление класса
    document.body.classList.add('article');
*/!*

    alert(document.body.className); // main page article
  </script>
</body>
```

Поэтому мы можем работать как со строкой полного класса, используя `className`, так и с отдельными классами, используя `classList`. То, что мы выбираем, зависит от наших целей.

Методы `classList`:

- `elem.classList.add/remove("class")` -- добавление/удаление класса.
- `elem.classList.toggle("class")` -- если класс существует, то удаляем его, иначе добавляем.
- `elem.classList.contains("class")` -- возвращает `true/false`, в зависимости от наличия данного класса.

Кроме того, `classList` является итерируемым, поэтому можно перечислить все классы таким образом:

```html run
<body class="main page">
  <script>
    for (let name of document.body.classList) {
      alert(name); // main, затем page
    }
  </script>
</body>
```

## Element style

Свойство `elem.style` - это объект, который соответствует тому, что написано в атрибуте `"style"`. Установить стиль так `elem.style.width="100px"` означает, как если бы мы имели в атрибуте `style="width:100px"`.

Для свойства из нескольких слов используется camelCase:

```js no-beautify
background-color  => elem.style.backgroundColor
z-index           => elem.style.zIndex
border-left-width => elem.style.borderLeftWidth
```

Например:

```js run
document.body.style.backgroundColor = prompt('background color?', 'green');
```

````smart header="Prefixed properties"
Стили с браузерным префиксом, например, `-moz-border-radius`, `-webkit-border-radius` также работают по тому же принципу:

```js
button.style.MozBorderRadius = '5px';
button.style.WebkitBorderRadius = '5px';
```

То есть тире `"-"` становится прописной буквой.
````

## Сброс стилей

Иногда мы хотим задать стиль, а затем удалить его.

Например, чтобы скрыть элемент, мы можем задать `elem.style.display = "none"`.

Затем мы можем удалить свойство `style.display`, чтобы вернуть к первоначальному состоянию. Вместо `delete elem.style.display` мы должны присвоить ему пустую строку: `elem.style.display = ""`.

```js run
// если мы запустим этот код, <body> "будет мигать"
document.body.style.display = "none"; // скрыть

setTimeout(() => document.body.style.display = "", 1000); // возврат к нормальному состоянию
```

Если мы установим в `display` пустую строку, то браузер применит CSS-классы и его встроенные стили, как если бы такого свойства `display` вообще не было.

````smart header="Полная перезапись `style.cssText`"
Обычно мы используем `style.*` для присвоения индивидуальных свойств стиля. Мы не можем установить весь список желаемых стилей, например, `div.style="color: red; width: 100px"`, потому что `div.style` -- это объект, и он доступен только для чтения.

Для задания нескольких стилей в одной строке используется специальное свойство `style.cssText`:

```html run
<div id="div">Button</div>

<script>
  // здесь мы даже можем устанавливать специальные флаги для стилей, например, "important"
  div.style.cssText=`color: red !important;
    background-color: yellow;
    width: 100px;
    text-align: center;
  `;

  alert(div.style.cssText);
</script>
```

Мы редко используем это, потому что такое присваивание удаляет все существующие стили: оно не добавляет, а заменяет их. Иногда можно удалить что-то необходимое. Но, все же, это можно использовать для новых элементов, когда мы точно знаем, что не удалим что-то важное.

То же самое можно сделать, если установить атрибут: `div.setAttribute('style', 'color: red...')`.
````

## Следите за единицами измерения

Единицы измерения в CSS должны быть представлены в стилевых значениях.

Например, мы должны устанавливать `10px`, а не просто `10` в свойство `elem.style.top`. Иначе это не сработает:

```html run height=100
<body>
  <script>
  *!*
    // не работает!
    document.body.style.margin = 20;
    alert(document.body.style.margin); // '' (пустая строка, присваивание игнорируется)
  */!*

    // сейчас добавим единицу измерения (px) - и это работает
    document.body.style.margin = '20px';
    alert(document.body.style.margin); // 20px

    alert(document.body.style.marginTop); // 20px
    alert(document.body.style.marginLeft); // 20px
  </script>
</body>
```

Пожалуйста, обратите внимание, как браузер "распаковывает" свойство `style.margin` в последних строках и выводит `style.marginLeft` и `style.marginTop` (и другие части внешнего отступа) из него.

## Вычисленные стили: getComputedStyle

Изменить стиль очень просто. Но как его *прочитать*?

Например, мы хотим знать размер, отступы, цвет элемента. Как это сделать?

**Свойство `style` оперирует только значением атрибута `"style"`, и не имеет никакого отношения к стилям из CSS, которые прописаны в .css файле, в тэге <style> или встроенных стилях браузера (далее сокращенно, CSS классы).**

Поэтому, используя `elem.style`, мы не можем прочитать ничего, что приходит из классов CSS.

Например, здесь `style` не может видеть отступы:

```html run height=60 no-beautify
<head>
  <style> body { color: red; margin: 5px } </style>
</head>
<body>

  Красный текст
  <script>
*!*
    alert(document.body.style.color); // пусто
    alert(document.body.style.marginTop); // пусто
*/!*
  </script>
</body>
```

...Но что, если нам нужно, скажем, увеличить отступ до 20px? Для начала нам надо это текущее значение получить.

Для этого есть метод: `getComputedStyle`.

Синтаксис:

```js
getComputedStyle(element[, pseudo])
```

element
: Элемент, значения для которого нужно получить

pseudo
: Указывается, если нужен стиль псевдо-элемента, например "::before". Пустая строка или отсутствие аргумента означают сам элемент.

В результате получился объект со свойствами стилей как `elem.style`, но теперь для всех CSS-классов.

Например:

```html run height=100
<head>
  <style> body { color: red; margin: 5px } </style>
</head>
<body>

  <script>
    let computedStyle = getComputedStyle(document.body);

    // сейчас мы можем прочитать отступ и цвет

    alert( computedStyle.marginTop ); // 5px
    alert( computedStyle.color ); // rgb(255, 0, 0)
  </script>

</body>
```

```smart header="Вычисленное (computed) и окончательное (resolved) значения"
Есть две концепции в [CSS](https://drafts.csswg.org/cssom/#resolved-values):

1. *Вычисленное* (computed) значение – это то, которое получено после применения всех CSS-правил и CSS-наследования. Например, `height:1em` или `font-size:125%`.
2. *Окончательное* ([resolved](https://drafts.csswg.org/cssom/#resolved-values)) значение – непосредственно применяемое к элементу. Значения `1em` или `125%` являются относительными. Браузер принимает вычисленное значение и делает все единицы измерения фиксированными и абсолютными, например, `height:20px` or `font-size:16px`. Для геометрических свойств разрешенные значения могут иметь плавающую точку, например, `width:50.5px`.

Давным-давно `getComputedStyle` был создан для получения вычисленных значений, но оказалось, что окончательные значения гораздо удобнее, и стандарт изменился.

Так что, в настоящее время `getComputedStyle` фактически возвращает окончательное значение свойства.
```

````warn header="`getComputedStyle` требует полное свойство!"
We should always ask for the exact property that we want, like `paddingLeft` or `marginTop` or `borderTopWidth`. Otherwise the correct result is not guaranteed.
Для правильного получения значения нужно указать точное свойство. Например: `paddingLeft`, `marginTop`, `borderTopWidth`. При обращении к сокращенному: `padding``, `margin`, `border` – правильный результат не гарантируется.

Например, если есть свойства `paddingLeft/paddingTop`, то что мы получим вызывая `getComputedStyle(elem).padding`? Ничего, или, может быть, "сгенерированное" значение из известных внутренних отступов? Стандарта для этого нет.

Есть и другие несоответствия. Например, некоторые браузеры (Chrome) отображают `10px` в документе ниже, а некоторые (Firefox) -- нет:

```html run
<style>
  body {
    margin: 10px;
  }
</style>
<script>
  let style = getComputedStyle(document.body);
  alert(style.margin); // пустая строка в Firefox
</script>
```
````

```smart header="\"Посещенные\" (visited) ссылки скрываются!"
Посещенные ссылки могут быть окрашены с помощью псевдокласса `:visited`.

Но `getComputedStyle` не дает доступ к этой информации, чтобы произвольная страница не могла определить, посещал ли пользователь ту или иную ссылку, проверив стили.

JavaScript может не отображать стили, применяемые с помощью `:visited`. Кроме того, в CSS есть ограничение, которое запрещает в целях безопасности применять к `:visited` CSS-стили, изменяющие геометрию элемента. Это гарантирует, что нет обходного пути для "плохой" страницы, чтобы проверить, была ли ссылка посещена и, следовательно, нарушить конфиденциальность.

```

## Итого

Для управления классами существуют два DOM-свойства:

- `className` -- строковое значение, хорошо управляет всем набором классов.
- `classList` - объект с методами `add/remove/toggle/contains`, подходит для отдельных классов.

Чтобы изменить стили:

- Свойство `style` является объектом с camelCased стилями. Чтение и запись в него имеет то же значение, что и изменение индивидуальных свойств в атрибуте `"style"`. Увидеть список методов, как применять `important` и другие редкие вещи можно в [MDN](mdn:api/CSSStyleDeclaration].

- Свойство `style.cssText` соответствует всему атрибуту `"style"`, полной строке стилей.

Для чтения окончательных стилей (для всех классов, после применения CSS и вычисления окончательных значений) используется:

- Метод `getComputedStyle(elem[, pseudo])` возвращает стилеобразный объект вместе с ними. Только для чтения.
