# Координаты

Чтобы передвигать элементы по экрану, нам следует познакомиться с системами координат.

Большинство соответствующих методов JavaScript работают в одной из двух указанных ниже систем координат:

1. **Относительно окна браузера** - похоже на `position:fixed`, отсчёт идёт от верхнего левого угла окна браузера.
    - мы будем обозначать эти координаты как `clientX/clientY`, причина выбора таких имён будет ясна позже, когда мы изучим свойства соответствующего события.
2. **Относительно документа** - похоже на `position:absolute` на уровне документа, отсчёт идёт от верхнего левого угла документа.
    - мы будем обозначать эти координаты как `pageX/pageY`.

Когда страница полностью прокручена наверх, то верхний левый угол окна совпадает с левым верхним углом документа, из чего следует, что обе системы координат тоже совпадают. Но если происходит прокрутка вниз, то координаты элементов в контексте окна меняются, так как они двигаются, но в то же время их координаты относительно документа остаются такими же.

На приведённой картинке слева показана ситуация до прокрутки страницы, а справа - после:

![](document-and-window-coordinates-scrolled.png)

Поскольку документ сдвинулся вверх, то:
- `pageY` - координата произвольной точки относительно документа осталась без изменений, так как отсчёт по-прежнему ведётся от верхней границы документа (сейчас она прокручена наверх).
- `clientY` - координата точки относительно окна изменилась (стрелка на рисунке стала короче), так как точка стала ближе к верхней границе окна.

В этой главе мы увидим и другие примеры координат элементов относительно окна и документа.

## Координаты относительно окна: getBoundingClientRect

Метод `elem.getBoundingClientRect()` возвращает координаты в контексте окна для минимального по размеру прямоугольника, который заключает в себе элемент `elem`, в виде объекта встроенного класса [DOMRect](https://www.w3.org/TR/geometry-1/#domrect).

Основные свойства объекта типа `DOMRect`:

- `x/y` -- X/Y-координаты начала прямоугольника относительно окна,
- `width/height` -- ширина/высота прямоугольника (могут быть отрицательными).

Дополнительно имеются вычисляемые свойства:

- `top/bottom` -- Y-координата верхнего/нижнего края,
- `left/right` -- X-координата левого/правого края.

```online
Кликните на кнопку, чтобы увидеть её координаты относительно окна:

<input id="brTest" type="button" value="Показать результат вызова button.getBoundingClientRect() для этой кнопки" onclick='showRect(this)'/>

<script>
function showRect(elem) {
  let r = elem.getBoundingClientRect();
  alert(`x:${r.x}
y:${r.y}
width:${r.width}
height:${r.height}
top:${r.top}
bottom:${r.bottom}
left:${r.left}
right:${r.right}
`);
}
</script>

Если вы прокрутите страницу, то позиция кнопки поменяется, и её координаты в контексте окна тоже.
```

Вот картинка с результатами вызова `elem.getBoundingClientRect()`:

![](coordinates.png)

Как вы видите, `x/y` и `width/height` полностью описывают прямоугольник. Остальные свойства могут быть легко вычислены на их основе:
- `left = x`
- `top = y`
- `right = x + width`
- `bottom = y + height`

Также:

- Координаты могут считаться с десятичной дробью, например `10.5`. Это нормально, ведь браузер использует дроби в своих внутренних вычислениях. Мы не обязаны округлять значения при установке `style.position.left/top`, браузер прекрасно понимает координаты с десятичными дробями.
- Координаты могут быть отрицательными. Например, если страница прокручена вниз и верхняя часть элемента `elem` ушла за пределы окна, то вызов `elem.getBoundingClientRect().top` вернёт отрицательное значение.

```smart header="Зачем вообще нужны вычисляемые свойства? Для чего существуют`top/left`, если есть `x/y`?"

Причина в том, что технически `width/height` могут принимать отрицательные значения. Прямоугольник начинается в точке `(x,y)` и `(width,height)` -- это на самом деле направление вектора расположения прямоугольника.

Отрицательные `width/height` могут быть полезны в случаях, когда направление прямоугольника важно, например при выделении текста мышью, чтобы корректно представлять начало и конец этого выделения.

Вот пример прямоугольника с отрицательными `width` и `height` (`width=-200`, `height=-100`):

![](coordinates-negative.png)

Прямоугольники на картинке выше начинаются из своих нижних правых углов и разворачиваются по направлению вверх и налево.

Как вы видите, свойства `left/top` здесь не равны `x/y`. То есть они не дублируют друг друга. Формулы выше могут быть исправлены с учётом возможных отрицательных значений  `width/height`. Это достаточно просто сделать, но редко требуется, так как результат вызова `elem.getBoundingClientRect()` всегда возвращает положительные значения для ширины/высоты.
```

```warn header="Internet Explorer и Edge: не поддерживают `x/y`"
Internet Explorer и Edge не поддерживают свойства `x/y` по историческим причинам.

Таким образом, мы можем либо сделать полифил (добавив соответствующие геттеры в `DomRect.prototype`), либо использовать `top/left`, так как они всегда одни и те же в результате, возвращаемом функцией `elem.getBoundingClientRect()`.
```

```warn header="Координаты right/bottom отличаются от одноимённых CSS-свойств"
Если мы сравним координаты в контексте окна и координаты при позиционировании средствами CSS, то мы увидим сходство при использовании `position:fixed`. Ведь такое CSS-позиционирование тоже происходит относительно окна браузера (или его видимой части).

Но в CSS свойство `right` означает расстояние от правого края, и свойство `bottom` означает расстояние от нижнего края окна браузера.

Если мы взглянем на картинку выше, то будет понятно, что в JavaScript это не так. Все координаты в контексте окна считаются от верхнего левого угла, включая `right/bottom`.
```

## elementFromPoint(x, y) [#elementFromPoint]

Вызов `document.elementFromPoint(x, y)` возвращает самый глубоко вложенный элемент в окне, находящийся по координатам `(x, y)`.

Синтаксис:

```js
let elem = document.elementFromPoint(x, y);
```

Например, код ниже выделяет с помощью стилей и выводит имя тега элемента, который сейчас в центре окна браузера:

```js run
let centerX = document.documentElement.clientWidth / 2;
let centerY = document.documentElement.clientHeight / 2;

let elem = document.elementFromPoint(centerX, centerY);

elem.style.background = "red";
alert(elem.tagName);
```

Поскольку используются координаты в контексте окна, то элемент может быть и другим в зависимости от того, имела ли место прокрутка.

````warn header="Для координат за пределами окна метод `elementFromPoint` возвращает `null`"
Метод `document.elementFromPoint(x,y)` работает, только если координаты `(x,y)` относятся к видимой части содержимого окна.

Если любая из координат представляет собой отрицательное число или превышает размеры окна, то возвращается `null`.

В большинстве случаев это не проблема, но всё же стоит держать сказанное в уме.

Вот типичная ошибка, которая может произойти, если в коде нет соответствующей проверки:

```js
let elem = document.elementFromPoint(x, y);
// если координаты ведут за пределы окна, то elem = null
*!*
elem.style.background = ''; // Ошибка!
*/!*
```
````

## Координаты для position:fixed

Чаще всего нам нужны координаты для позиционирования чего-либо. В CSS для позиционирования элемента относительно окна браузера используется свойство `position:fixed` вместе со свойствами `left/top` (или `right/bottom`).

Мы можем вызвать `getBoundingClientRect`, чтобы получить координаты элемента, а затем показать что-то около него.

Например, функция `createMessageUnder(elem, html)` ниже показывает сообщение под элементом `elem`:

```js
let elem = document.getElementById("coords-show-mark");

function createMessageUnder(elem, html) {
  // создаём элемент, который будет содержать сообщение
  let message = document.createElement('div');
  // для стилей лучше было бы использовать css-класс здесь
  message.style.cssText = "position:fixed; color: red";

*!*
  // устанавливаем координаты элементу, не забываем про "px"!
  let coords = elem.getBoundingClientRect();

  message.style.left = coords.left + "px";
  message.style.top = coords.bottom + "px";
*/!*

  message.innerHTML = html;

  return message;
}

// Использование:
// добавим сообщение на страницу на 5 секунд
let message = createMessageUnder(elem, 'Hello, world!');
document.body.append(message);
setTimeout(() => message.remove(), 5000);
```

```online
Кликните кнопку, чтобы увидеть пример в действии:

<button id="coords-show-mark">Кнопка с id="coords-show-mark", сообщение появится под ней</button>
```

Код может быть изменён, чтобы показывать сообщение слева, справа, снизу, применять к нему CSS-анимации и так далее. Это просто, так как в нашем распоряжении имеются все координаты и размеры элемента.

Но обратите внимание на одну важную деталь: при прокрутке страницы сообщение уплывает от кнопки.

Причина весьма очевидна: сообщение позиционируется с помощью `position:fixed`, поэтому оно остаётся всегда на том же самом месте в окне при прокрутке страницы.

Чтобы изменить это, нам нужно использовать другую систему координат, где сообщение позиционировалось бы относительно документа, и свойство `position:absolute`.

## Координаты относительно документа

В такой системе координат отсчёт ведётся от левого верхнего угла документа, не окна.

В CSS координаты относительно окна браузера соответствуют свойству `position:fixed`, а координаты относительно документа -- свойству `position:absolute` на самом верхнем уровне вложенности.

Мы можем воспользоваться свойствами `position:absolute` и `top/left`, чтобы привязать что-нибудь к конкретному месту в документе. При этом прокрутка страницы не имеет значения. Но сначала нужно получить верные координаты.

Для ясности обозначим координаты в контексте окна как `(clientX,clientY)` и в контексте документа как `(pageX,pageY)`.

Если страница не прокручена, то координаты в обеих системах совпадают, равно как и точка отсчёта:

![](document-window-coordinates-zero.png)

Но при прокрутке значения `(clientX,clientY)` меняются, потому что они привязаны к окну браузера, а `(pageX,pageY)` остаются такими же.

Вот та же самая страница после вертикальной прокрутки:

![](document-window-coordinates-scroll.png)

- значение `clientY` заголовка сегодняшнего горячего материала стало равным `0`, потому что верхний край элемента достиг верхней границы окна.
- значение `clientX` не поменялось, так как не было горизонтальной прокрутки.
- значения координат `pageX` и `pageY` тоже не изменились, потому что они берутся относительно документа.

## Получаем координаты в контексте документа [#getCoords]

Не существует стандартного метода, который возвращал бы координаты элемента относительно документа, но мы можем написать его сами.

Две системы координат связаны следующими формулами:
- `pageY` = `clientY` + высота вертикально прокрученной части документа.
- `pageX` = `clientX` + ширина горизонтально прокрученной части документа.

Функция `getCoords(elem)` берёт координаты в контексте окна с помощью `elem.getBoundingClientRect()` и добавляет к ним значение соответствующей прокрутки:

```js
// получаем координаты элемента в контексте документа
function getCoords(elem) {
  let box = elem.getBoundingClientRect();

  return {
    top: box.top + pageYOffset,
    left: box.left + pageXOffset
  };
}
```

## Итого

Любая точка на странице имеет координаты:

1. Относительно окна браузера -- `elem.getBoundingClientRect()`.
2. Относительно документа -- `elem.getBoundingClientRect()` плюс прокрутка.

Координаты в контексте окна подходят для использования с `position:fixed`, а координаты относительно документа -- для использования с `position:absolute`.

Каждая из систем координат имеет свои преимущества и недостатки. Иногда будет лучше применить одну, а иногда -- другую, как это и происходит с позиционированием в CSS, где мы выбираем между `absolute` и `fixed`.
