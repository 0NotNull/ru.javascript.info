
# Элемент Template

Встроенный элемент `<template>` предназначен для хранения разметки. Браузер в целом игнорирует его содержимое, проверяя при этом валидность синтаксиса. Однако можно манипулировать этим элементом с помощью JavaScript, чтобы создать другие элементы.

В принципе, для хранения разметки мы могли бы создать невидимый элемент в любом месте HTML. Что такого особенного в `<template>`?

Во-первых, его содержимым может быть любой корректный HTML-код, даже тот, который обычно должен находиться в родителе.

К примеру, мы можем поместить сюда строку таблицы `<tr>`:
```html
<template>
  <tr>
    <td>Contents</td>
  </tr>
</template>
```

Обычно, если элемент `<tr>` мы поместим, скажем, в `<div>`, браузер обнаружит неправильную структуру DOM и "исправит" её, добавив снаружи `<table>`. Это может оказаться не тем, что мы хотели. `<template>` же оставит разметку ровно такой, какой мы её туда поместили.

Также внутри `<template>` возможно поместить стили и скрипты:

```html
<template>
  <style>
    p { font-weight: bold; }
  </style>
  <script>
    alert("Hello");
  </script>
</template>
```

Браузер рассматривает содержимое `<template>` как находящееся "вне документа", поэтому стили, определенные в нём, не применяются, скрипты не выполнятся, `<video autoplay>` не запустится и т.д.

Содержимое оживёт (скрипт выполнится), когда мы поместим его в нужное нам место.

## Использование template

Содержимое шаблона доступно по его свойству `content` в качестве [DocumentFragment](info:modifying-document#document-fragment) -- особый тип DOM-узла.

Можно обращаться с ним так же, как и с любыми другими DOM-узлами, за исключением одной особенности, -- помещая его в каком-то месте, на деле мы помещаем туда его потомков.

Пример:

```html run
<template id="tmpl">
  <script>
    alert("Hello");
  </script>
  <div class="message">Hello, world!</div>
</template>

<script>
  let elem = document.createElement('div');

*!*
  // Клонируем содержимое шаблона для того, чтобы переиспользовать его несколько раз
  elem.append(tmpl.content.cloneNode(true));
*/!*

  document.body.append(elem);
  // Сейчас скрипт из <template> выполнится
</script>
```

Давайте перепишем пример Shadow DOM из прошлой главы учебника с помощью `<template>`:

```html run untrusted autorun="no-epub" height=60
<template id="tmpl">
  <style> p { font-weight: bold; } </style>
  <p id="message"></p>
</template>

<div id="elem">Click me</div>

<script>
  elem.onclick = function() {
    elem.attachShadow({mode: 'open'});

*!*
    elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)
*/!*

    elem.shadowRoot.getElementById('message').innerHTML = "Hello from the shadows!";
  };
</script>
```

Когда мы клонируем и вставляем `tmpl.content` в строке `(*)`, в итоге вставляются его потомки (`<style>`, `<p>`).

Именно они и формируют теневой DOM:

```html
<div id="elem">
  #shadow-root
    <style> p { font-weight: bold; } </style>
    <p id="message"></p>
</div>
```

## Итого

Подводим итоги:

- Содержимым `<template>` может быть любой синтаксически корректный HTML.
- Содержимое `<template>` рассматривается как то, что находится "вне документа", поэтому оно ни на что не влияет.
- Мы можем получить доступ к `template.content` из JavaScript, клонировать его и переиспользовать в новом компоненте.

Элемент `<template>` уникальный по следующим причинам:

- Браузер проверяет синтаксис внутри него (в отличие от использования строки в скрипте).
- ...При этом позволяет использовать любые HTML-теги, даже те, которые без соответствующей обёртки не используются (например `<tr>`).
- Его содержимое оживает (скрипты выполняются, `<video autoplay>` проигрывается и т. д.), когда помещается в документ.

Тег `<template>` не предназначен для каких-то сложных механизмов итерации, связывания данных или подстановки переменных, что делает его проще и слабее фреймворков. Однако их можно строить поверх него.
