# Общение между окнами

Политика "Same Origin" (одинаковый источник) ограничивает доступ окон и фреймов друг к другу.

Идея заключается в том, что если у пользователя открыто две страницы: `john-smith.com` и `gmail.com`, то у скрипта со страницы `john-smith.com` не будет возможности прочитать письма из `gmail.com`. Таким образом задача политики "Same Origin" - защитить данные пользователя от возможной кражи. 

## Same Origin [#same-origin]

Два URL соответствуют политике в том случае, если они имеют одинаковые: протокол, домен и порт.

URL, которые имеют один и тот же источник:

- `http://site.com`
- `http://site.com/`
- `http://site.com/my/page.html`

И те, которые не имеют:

- <code>http://<b>www.</b>site.com</code> (другой домен: `www.` важен)
- <code>http://<b>site.org</b></code> (другой домен: `.org` важен)
- <code><b>https://</b>site.com</code> (другой протокол: `https`)
- <code>http://site.com:<b>8080</b></code> (другой порт: `8080`)

"Same Origin" говорит о следующем:

- если у нас есть ссылка на другой объект `window`, например, на попап созданный с помощью `window.open` или на `window` из `<iframe>` и все они соответствуют политике "Same Origin", тогда у нас будет полный доступ к ним.
- в противном случае, если они имеют другие источники, доступ к контенту будет ограничен: переменные, объект `document`, ко всему. Единственное исключение - объект `location`: его можно изменять (таким образом перенаправляя пользователя). Но нельзя *читать* `location` (нельзя узнать где находится пользователь, чтобы не было никаких утечек информации).

Давайте рассмотрим несколько примеров. Сначала посмотрим страницы которые имеют одинаковый источник и не конфликтуют с политикой "Same Origin" и после этого мы разберём отправку сообщение между окнами, которая позволяет обойти политику "Same Origin".

````warn header="Суб-домены могут иметь одинаковый источник"
Есть небольшое исключение в политике "Same Origin".

Если окна имеют одинаковый домен второго уровня, например `john.site.com`, `peter.site.com` и `site.com` (так что их общий домен второго уровня `site.com`), они могут быть восприняты как "имеющие общий источник".

Чтобы это работало, на всех страницах (включая `site.com`) необходимо запустить код:

```js
document.domain = 'site.com';
```

После этого они смогут взаимодействовать без ограничений. Напомним, что это доступно только для страниц с одинаковым доменом второго уровня.
````

## Доступ к содержимому iframe

Рассмотрим первый пример с ифреймом. С одной стороны `<iframe>` это обычный тег, как `<script>` или `<img>`, с другой - это окно в окне.

Встроенное окно имеет свои собственные объекты `document` и `window`.

Мы можем обращаться к ним, используя свойства:

- `iframe.contentWindow` ссылка на объект window внутри `<iframe>`.
- `iframe.contentDocument` ссылка на объект document внутри `<iframe>`.

Когда мы обращаемся к встроенному окну, браузер проверяет имеет ли ифрейм тот же источник. Если это не так, тогда доступ будет запрещён (с исключениями, о которых говорилось выше).

Например, вот `<iframe>` у которого другой источник:

```html run
<iframe src="https://example.com" id="iframe"></iframe>

<script>
  iframe.onload = function() {
    // можно получить ссылку на внутренний window
    let iframeWindow = iframe.contentWindow;

    try {
      // ...но document внутри
      let doc = iframe.contentDocument;
    } catch(e) {
      alert(e); // выведет ошибку безопасности (другой источник)
    }

    // также нельзя прочитать URL страницы внутри
    try {
      alert(iframe.contentWindow.location);
    } catch(e) {
      alert(e); // ошибка безопасности
    }

    // ...но его можно изменять (и таким образом загрузить что-то еще в iframe)!
    iframe.contentWindow.location = '/'; // работает

    iframe.onload = null; // очистим обработчик, чтобы этот код запустился только один раз
  };
</script>
```

Код выше выведет ошибку для любых операций, кроме:

- Получение ссылки на внутренний объект window `iframe.contentWindow`
- Изменение `location`.

```smart header="`iframe.onload` и `iframe.contentWindow.onload`"
Свойство `iframe.onload` на самом деле тоже самое, что и `iframe.contentWindow.onload`. Оно сработает, когда встроенное окно полностью загрузится со всеми ресурсами.

...Но `iframe.onload` сработает всегда, в то время, как `iframe.contentWindow.onload` требует выполнения "Same Origin".
```

А теперь пример, когда источник одинаковый. Мы можем делать со встроенным окном всё что захотим:

```html run
<iframe src="/" id="iframe"></iframe>

<script>
  iframe.onload = function() {
    // просто сделаем что-то
    iframe.contentDocument.body.prepend("Hello, world!");
  };
</script>
```

### Пожалуйста, подождите, пока загрузится iframe

Когда iframe создан, у него сразу есть `document`. Но этот `document` -- другой, не тот который в конечном итоге будет загружен!

Посмотрим:


```html run
<iframe src="/" id="iframe"></iframe>

<script>
  let oldDoc = iframe.contentDocument;
  iframe.onload = function() {
    let newDoc = iframe.contentDocument;
*!*
    // загруженный document не тот, который в начале!
    alert(oldDoc == newDoc); // false
*/!*
  };
</script>
```

Это хорошо известная ловушка для разработчиков. Не следует сразу начинать работать с `document`, потому что это *неправильный `document`*. Если добавить к нему обработчик событий, он будет проигнорирован.

...Событие `onload` сработает, когда iframe загрузится полностью со всеми ресурсами. Но что если мы хотим запустить код раньше, например, на событие `DOMContentLoaded` встроенного документа?

Это невозможно, если ифрейм из другого источника. Но если источники совпадают, мы можем попробовать поймать момент, когда появляется новый документ и после этого добавить необходимые обработчик:

```html run
<iframe src="/" id="iframe"></iframe>

<script>
  let oldDoc = iframe.contentDocument;

  // каждый 100 мс проверяем, не изменился ли document
  let timer = setInterval(() => {
    if (iframe.contentDocument == oldDoc) return;

    // когда document изменился, установим обработчики
    iframe.contentDocument.addEventListener('DOMContentLoaded', () => {
      iframe.contentDocument.body.prepend('Hello, world!');
    });

    clearInterval(timer); // отключим setInterval, потому что он нам больше не нужен
  }, 100);
</script>
```

Если вы знаете более удачное решение -- напишите об этом в комментариях.

## window.frames

Другой способ получить объект `window` из `<iframe>` -- забрать его из именованной коллекции `window.frames`:

- По номеру: `window.frames[0]` -- объект `window` для первого фрейма в документе. 
- По имени: `window.frames.iframeName` -- объект `window` для фрейма со свойством `name="iframeName"`.

Например:

```html run
<iframe src="/" style="height:80px" name="win" id="iframe"></iframe>

<script>
  alert(iframe.contentWindow == frames[0]); // true
  alert(iframe.contentWindow == frames.win); // true
</script>
```

Ифрейм может иметь другие ифреймы внутри. Таким образом объекты `window` создают иерархию.

Навигация по ним выглядит так:

- `window.frames` -- колекция "дочерних" windows (для вложенных ифреймов).
- `window.parent` -- ссылка на "родительский" (внешний) window.
- `window.top` -- ссылка на самого верхнего родителя.

Например:

```js run
window.frames[0].parent === window; // true
```

Можно использовать свойство `top`, чтобы проверять открыт ли текущий документ внутри ифрейма или нет:

```js run
if (window == top) { // текущий window == window.top?
  alert('Скрипт находится в самом верхнем объекте window, не во фрейме');
} else {
  alert('Скрипт запущен во фрейме!');
}
```

## Атрибут sandbox (песочница)

Атрибут `sandbox` позволяет исключить определенные действия внутри `<iframe>` чтобы предотвратить выполнение ненадежного кода. Атрибут помещает ифрейм в "песочницу", отмечая его как имеющий другой источник и/или накладывая на него дополнительные ограничения.

По умолчанию, для `<iframe sandbox src="...">` список ограничений такой же как для ифрейма. В аттрибут можно передать список "исключений" через пробел, которые не нужно применять к ифрейму: `<iframe sandbox="allow-forms allow-popups">`. Ограничения из списка не будут применены.

Другими словами, если у атрибута `"sandbox"` нет значения, то браузер применяет максимум ограничений, но через пробел можно указать те из них, которые мы не хотим применять.

Список ограничений:

`allow-same-origin`
: `"sandbox"` принудительно устанавливает "разные источники" для ифрейма. Другими словами, он заставляет браузер воспринимать `iframe`, как пришедший из другого источника, даже если `src` содержит тот же сайт. Со всеми возможными ограничениями для скрипта. Эта опция отключает эту особенность.

`allow-top-navigation`
: Позволяет ифрейму менять `parent.location`.

`allow-forms`
: Позволяет отправлять формы из ифрейма.

`allow-scripts`
: Позволяет запускать скрипты из ифрейма.

`allow-popups`
: Позволяет открывать всплывающие окна их ифрейма с помощью `window.open`.

Больше опций [в руководстве](mdn:/HTML/Element/iframe).

Пример ниже демонстрирует ифрейм помещенный в песочницу со стандартным набором ограничений: `<iframe sandbox src="...">`. На странице содержится JavaScript и форма.

Обратите внимание, что ничего не работает. Таким образом, набор ограничений по умолчанию очень строгий:

[codetabs src="sandbox" height=140]


```smart
Атрибут `"sandbox"` создан только для того чтобы *добавлять* ограничения. Он не может удалять их. В частности, он не может ослабить ограничения одного и того же источника, если ифрейм имеет другой источник.
```

## Отправка сообщений между окнами

Интерфейс `postMessage` позволяет окнам общаться между собой независимо от их происхождения.

Это способ обойти политику "Same Origin". Он позволяет обмениваться информаций, скажем `john-smith.com` и `gmail.com`, но только в том случаее, если оба сайта согласны и вызывают сооветствующиее JavaScript функции. Это делает общение безопасным для пользователя.

Интерфейс имеет две части.

### postMessage

Окно, которое хочет отправить сообщение должно вызвать метод [postMessage](mdn:api/Window.postMessage) окна получателя. Другими словами, если мы хотим отправить сообщение в `win`, тогда нам следует вызвать `win.postMessage(data, targetOrigin)`.

Аргументы:

`data`
: Данные для отправки. Может быть любым объектом, данные клонируются с использованием «алгоритма структурированного клонирования». IE поддерживает только строки, поэтому мы должны использовать метод `JSON.stringify` на сложных объектах, чтобы поддержать этот браузер.

`targetOrigin`
: Определяет источник для окна-получателя, так что только окно из данного источника могло получать сообщение.

`targetOrigin` является мерой безопасности. Помните, что если окно-получатель происходит из другого источника, мы не можем прочитать его `location`. Таким образом, мы не можем быть уверены, какой сайт открыт в заданном окне прямо сейчас: пользователь мог перейти.

Если определить `targetOrigin`, тогда мы можем быть уверены, что window получит данные, только в том случае, если мы до сих пор на сайте. Хорошо, когда данные учитывают это.

Например, здесь `win` получит сообщения только в том случае, если document из источника `http://example.com`:

```html no-beautify
<iframe src="http://example.com" name="example">

<script>
  let win = window.frames.example;

  win.postMessage("message", "http://example.com");
</script>
```

Если эта проверка не нужна, в `targetOrigin` может быть передано `*`.

```html no-beautify
<iframe src="http://example.com" name="example">

<script>
  let win = window.frames.example;

*!*
  win.postMessage("message", "*");
*/!*
</script>
```


### onmessage

Чтобы получать сообщения, окно-получатель должно иметь обработчик события `message` (сообщение). Оно срабатывает когда был вызван метод `postMessage` (и проверка `targetOrigin` пройдена успешно).

Объект события имеет специфичные свойства:

`data`
: Данные из `postMessage`.

`origin`
: Источник отправителя, например, `http://javascript.info`.

`source`
: Ссылка на окно-отправитель. Сразу можно отправить что-то в ответ, вызвав `postMessage`.

Чтобы добавить обрабочик, следуюет использовать метод `addEventListener`, короткий синтаксис `window.onmessage` не работает.

Вот пример:

```js
window.addEventListener("message", function(event) {
  if (event.origin != 'http://javascript.info') {
    // давайте игнорировать всё с неизвестных доменов
    return;
  }

  alert( "received: " + event.data );
});
```

Полный пример:

[codetabs src="postmessage" height=120]

```smart header="Без задержек"
Между `postMessage` и событием `message` не существует задержки. Это происходит синхронно, гораздо быстрее, чем `setTimeout(...,0)`.
```

## Итого

Чтобы вызвать метод или получить контет из другого окна, нам необходимо иметь ссылку на него.

Для всплывающих окон есть два свойства:
- `window.open` -- открывает новое окно и возвращает ссылку на него,
- `window.opener` -- ссылка на открывающее окно из всплывающего окна

Для ифреймов, мы можем иметь доступ к родителям/потомкам используя:
- `window.frames` -- коллекция объектов window вложенных ифреймов,
- `window.parent`, `window.top` -- это ссылки на родительское окно и окно самого верхнего уровня,
- `iframe.contentWindow` это объект window внутри тега `<iframe>`.

Если окна имеют одинаковые источники (протокол, домен, порт), то они могут делать друг с другом все, что угодно.

В противном случае возможны только следующие действия:
- Изменение свойства location другого окна (доступ только на запись).
- Отправить туда сообщение.


Исключения:
- Окна, которые имеют общий домен второго уровня: `a.site.com` и `b.site.com`. И установленное свойство `document.domain='site.com'` в обоих окнах переведёт их в состояние "одного истоника".
- Если у ифрейма установлен атрибут `sandbox`, это принудительно переведёт окна в состояние "разных источников", если не установить в атрибут значение `allow-same-origin`. Это можно использовать для запуска ненадежного кода в ифрейме с того же сайта.

Интерфейс `postMessage` позволяет двум окнам общаться с проверками безопасности:

1. Отправитель вызывает `targetWin.postMessage(data, targetOrigin)`.
2. Если `targetOrigin` не `'*'`, тогда браузер проверяет имеет ли `targetWin` URL из `targetWin` сайта.
3. Если это так, тогда `targetWin` вызывает событие `message` со специальными свойствами:
    - `origin` -- источник окна отправителя (например, `http://my.site.com`)
    - `source` -- ссылка на окно отправитель.
    - `data` -- данные, может быть объектом везде, кроме IE (в IE только строки).

    В окне-получателе следует добавить обработчик для этого события с помощью метода `addEventListener`.
