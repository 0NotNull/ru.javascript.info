# Скобочные группы

Часть шаблона можно заключить в скобки `pattern:(...)`. Это называется "скобочная группа".

У такого выделения есть два эффекта:

1. Позволяет поместить часть совпадения в отдельный массив.
2. Если установить квантификтор после скобок, то он будет применяться к всему содержимому скобки, а не к одному символу.

## Пример

В примере ниже шаблон `pattern:(go)+` один или более `match:'go'`:

```js run
alert( 'Gogogo now!'.match(/(go)+/i) ); // "Gogogo"
```

Без скобок, шаблон `pattern:/go+/` означает `subject:g` и, идущий после него, `subject:o`, который повторяется один или более раз. Например, `match:goooo` или `match:gooooooooo`.

Скобки группирую символы в слово `pattern:(go)`.

Сделаем что-то более сложное -- регулярное выражение, которое соответствует адресу электронной почты.

Пример такой почты:

```
my@mail.com
john.smith@site.com.uk
```

Шаблон: `pattern:[-.\w]+@([\w-]+\.)+[\w-]{2,20}`.

1. Первая часть `pattern:[-.\w]+` (перед `@`) может включать любые числовые или буквенные символы, точку и тире, чтобы соответствовать `match:john.smith`.
2. Затем идет `pattern:@` и домен. Это может быть поддомен (например, `host.site.com.uk`), поэтому мы сопоставляем его как слово, за которым следует точка `pattern:([\w-]+\.)` (повторяется). Затем в конце должно быть слово: `match:com` или `match:uk` (но не очень длинное: 2-20 символов).

Это выражение не идеально, но достаточно хорошее для исправления ошибок и опечаток.

Например,  мы можем найти все электронные адреса в строке:

```js run
let reg = /[-.\w]+@([\w-]+\.)+[\w-]{2,20}/g;

alert("my@mail.com @ his@site.com.uk".match(reg)); // my@mail.com, his@site.com.uk
```

В примере скобки используются для создания повторяющейся группы `pattern:(...)+`. Но есть и другие применения. Посмотрим на них.

## Содержимое скобок  

Группы скобок нумируются слева направо. Поисковый движок запоминает содержимое в каждой группе и позволяет ссылаться на него в шаблоне регулярного выражения или строке для замены.

Например, мы хотим найти HTML теги `pattern:<.*?>` и обрадотать их.

Давайте заключим внутреннее содержимое в круглые скобки: `pattern:<(.*?)>`.

Соберем их в массив:

```js run
let str = '<h1>Hello, world!</h1>';
let reg = /<(.*?)>/;

alert( str.match(reg) ); // Array: ["<h1>", "h1"]
```

Вызов [String#match](mdn:js/String/match) возвращает группы только если регулярное выражение не имеет флаг `pattern:/.../g`.

Если необходимы все совпадения с их группировкой, то мы можем использовать `.matchAll` или `regexp.exec` как описано в <info:regexp-methods>:

```js run
let str = '<h1>Hello, world!</h1>';

// два совпадения: теги открытия <h1> и закрытия </h1>
let reg = /<(.*?)>/g;

let matches = Array.from( str.matchAll(reg) );

alert(matches[0]); //  Array: ["<h1>", "h1"]
alert(matches[1]); //  Array: ["</h1>", "/h1"]
```

Здесь мы имеем два совпадения для `pattern:<(.*?)>`. Каждый из них является массивом с полным совдаением и группой.

## Вложенные группы

Скобки могут быть и вложенными. В этом случае нумерация также идёт слева направо.

Например, при поиске тега в `subject:<span class="my">` нас может интересовать:

1. Содержимое тега целиком: `match:span class="my"`.
2. Название тега: `match:span`.
3. Аттрибуты тега: `match:class="my"`.

Давайте добавим скобки для них:

```js run
let str = '<span class="my">';

let reg = /<(([a-z]+)\s*([^>]*))>/;

let result = str.match(reg);
alert(result); // <span class="my">, span class="my", span, class="my"
```

Вот так выглядят скобочные группы:

![](regexp-nested-groups.png)

С нулевым индексом `result` всегда идет совпадение полностью.

Затем группы, нумеруемые слева направо. Та, которая открывается первой, получает первую группу `result[1]`. Она заключает в себе все содержимое тега.

Затем в `result[2]` идет группа от второй открывающей скобки  `pattern:(` до соответствующей `pattern:)` -- имя тега, тогда мы группируем не пространства, а группу аттрибутов для `result[3]`.

**Даже если скобочная группа необязательна и не входит в совпадение, соответствующий элемент массива `result` существует (и равен `undefined`).**

Например, рассмотрим регэксп `pattern:a(z)?(c)?`. Он ищет `"a"`, за которой не обязательно идёт буква `"z"`, за которой не обязательно идёт буква `"c"`.

Если запустить его на строку из одной буквы `subject:a`, то результат будет таков:

```js run
let match = 'a'.match(/a(z)?(c)?/);

alert( match.length ); // 3
alert( match[0] ); // a (всё совпадение)
alert( match[1] ); // undefined
alert( match[2] ); // undefined
```

Массив имеет длинну `3`, но все скобочные группы пустые.

А теперь более сложная ситуация для строки `subject:ack`:

```js run
let match = 'ack'.match(/a(z)?(c)?/)

alert( match.length ); // 3
alert( match[0] ); // ac (всё совпадение)
alert( match[1] ); // undefined, потому что для (z)? ничего нет
alert( match[2] ); // c
```

Длинна массива всегда: `3`. Для группы `pattern:(z)?` ничего нет, поэтому результат `["ac", undefined, "c"]`.

## Именованные группы

Запоминать группы по числам сложно. Для простых шаблонов это допустимо, но в более сложных случаях мы можем дать имена скобкам.

Это делается добавлением `pattern:?<name>` непосредственно после открытия скобки. Например:

```js run
*!*
let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
*/!*
let str = "2019-04-30";

let groups = str.match(dateRegexp).groups;

alert(groups.year); // 2019
alert(groups.month); // 04
alert(groups.day); // 30
```

Как вы можете видеть, группы располагаются в свойстве  `.groups` совпадения.

МЫ также можем использовать их для замены, как `pattern:$<name>` (как в случае с `$1..9`, но использовать имя вместо цифры).

Например, давайте переделаем информацию о дате `day.month.year`:

```js run
let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;

let str = "2019-04-30";

let rearranged = str.replace(dateRegexp, '$<day>.$<month>.$<year>');

alert(rearranged); // 30.04.2019
```

Если используем функцию, тогда именованный объект `groups` всегда является последним аргументом:

```js run
let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;

let str = "2019-04-30";

let rearranged = str.replace(dateRegexp,
  (str, year, month, day, offset, input, groups) =>
   `${groups.day}.${groups.month}.${groups.year}`
);

alert(rearranged); // 30.04.2019
```

Обычно, когдам мы планируем использовать именованные группы, то нам не нужны позиционированные аргументы функции. Для большинства реальных случаев нам нужны только `str` и` groups`.

Таким образом, мы можем написать это немного короче:

```js
let rearranged = str.replace(dateRegexp, (str, ...args) => {
  let {year, month, day} = args.pop();
  alert(str); // 2019-04-30
  alert(year); // 2019
  alert(month); // 04
  alert(day); // 30
});
```


## Исключение из запоминания через ?:

Бывает так, что скобки нужны, чтобы квантификатор правильно применился, но мы не хотим содержимое в результате.

Скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало `pattern:?:`.

Например, если мы хотим найти `pattern:(go)+`, но не хотим запоминать содержимое (`go`) в отдельный элемент массива, то можем написать так: `pattern:(?:go)+`.

В примере ниже мы получаем только имя "John", как отдельный член массива `results`:

```js run
let str = "Gogo John!";
*!*
// исключает Gogo из запоминания
let reg = /(?:go)+ (\w+)/i;
*/!*

let result = str.match(reg);

alert( result.length ); // 2
alert( result[1] ); // John
```

## Итого

- Скобки могут:
  - запоминать `(...)`, нумеровать слева направо, давать доступ по номеру.
  - именовать группы `(?<name>...)`, давать доступ по имени.
  - исключать из запоминания `(?:...)`, использоваться только для применения квантификатора ко всем группам.
