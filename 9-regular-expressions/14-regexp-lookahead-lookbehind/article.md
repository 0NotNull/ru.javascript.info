# Опережающие и ретроспективные проверки

В некоторых случаях нам нужно найти соответствие шаблону, за которым следует другой шаблон. Например, нам нужно найти цену одной индейки из строки `subject:1 индейка стоит 30€`.

Следовательно, нам нужно число (в данном примере - это целое число), после которого следует знак валюты `subject:€`.

Именно для таких задач и существует опережающая проверка.

## Опережающая проверка

Синтаксис: `pattern:x(?=y)`
Пояснение: найди такой `pattern:х`, за которым обязательно следует `pattern:y`.

Для целого числа, за которым идёт знак `subject:€`, шаблон регулярного выражения будет `pattern:\d+(?=€)`:

```js run
let str = "1 индейка стоит 30€";

alert( str.match(/\d+(?=€)/) ); // 30 (число 1 было проигнорировано, так как за ним НЕ следует `subject:€`)
```

Допустим, в этот раз нам нужно узнать количество индеек, которое можно купить за 30€ - число, за которым не следует знак `subject:€`.

Для этой задачи мы можем применить негативную опережающую проверку.

Синтаксис: `pattern:x(?!y)`
Пояснение: найди такой `pattern:х`, за которым НЕ следует `pattern:y`.

```js run
let str = "2 индейки стоят 60€";

alert( str.match(/\d+(?!€)/) ); // 2 (в этот раз была проигнорирована цена)
```

## Ретроспективная проверка

Опережающие проверки позволяют задавать условия на то, что "идёт после".

Ретроспективная проверка выполняет такую же функцию, но с просмотром назад. Другими словами, она находит соответствие шаблону, только если перед ним есть что-то заранее определённое.

Синтаксис:
- Позитивная ретроспективная проверка: `pattern:(?<=y)x`, выдаёт совпадение на `pattern:x` при условии, что перед ним ЕСТЬ `pattern:y`.
- Негативная ретроспективная проверка: `pattern:(?<!y)x`, выдаёт совпадение на `pattern:x` при условии, что перед ним НЕТ `pattern:y`.

Чтобы протестировать ретроспективную проверку, давайте поменяем валюту на доллары США. Знак доллара обычно ставится перед суммой денег, поэтому для того чтобы найти `$30`, мы используем `pattern:(?<=\$)\d+`, так как это даст нам сумму перед `subject:$`.

```js run
let str = "1 индейка стоит $30";

alert( str.match(/(?<=\$)\d+/) ); // 30 (проигнорировалось число 1)
```

Если нам необходимо найти количество индеек -- число, перед которым не идёт `subject:$`, мы можем использовать негативную ретроспективную проверку `pattern:(?<!\$)\d+`:

```js run
let str = "2 индейки стоят $60";

alert( str.match(/(?<!\$)\d+/) ); // 2 (проигнорировалась цена)
```

## Захват групп

Как правило, то что находится внутри lookaround (общее наименование для опережающей и ретроспективной проверок), не включается в результат совпадения.

Например, в шаблоне `pattern:\d+(?!€)` знак `pattern:€` не будет включён в результат.

Однако, существует способ, чтобы захватить весь lookaround или же его часть. Нам всего лишь нужно заключить lookaround в дополнительные скобки.

В следующем примере знак валюты `pattern:(€|kr)` будет включён в результат вместе с суммой:

```js run
let str = "1 индейка стоит 30€";
let reg = /\d+(?=(€|kr))/; // добавлены дополнительные скобки вокруг €|kr

alert( str.match(reg) ); // 30, €
```

Тоже самое можно применить к ретроспективной проверке:

```js run
let str = "1 индейка стоит $30";
let reg = /(?<=(\$|£))\d+/;

alert( str.match(reg) ); // 30, $
```

Обратите внимание, что порядок выдачи результата ретроспективной проверки остаётся прежним, хотя скобки из опережающей проверки расположены ПЕРЕД основным шаблоном.

Обычно совпадения с выражениями в скобках нумеруются по порядку -- слева направо. Однако, ретроспективная проверка является исключением, так как при ней совпадение с выражением в скобках всегда идёт после результата основного шаблона. Так, в нашем примере совпадение с основным шаблоном `pattern:\d+` будет идти первым, а результат для `pattern:(\$|£)` будет вторым.

## Итого

Опережающая и ретроспективная проверки (обычно их называют lookaround) удобны для простых регулярных выражений, когда мы не хотим включать определённый шаблон в совпадение в зависимости от контекста до или после.

В некоторых случаях, мы можем сделать это вручную - найти все совпадения и потом отфильтровать по контексту в цикле.
Важно не забывать, что `str.matchAll` и `reg.exec` возвращают совпадения со свойством `.index`, поэтому мы знаем их точное расположение.
Однако, для таких заданий лучше использовать регулярные выражения.

Виды проверок:

| Паттерн            | Тип                        | Совпадение                      |
|--------------------|----------------------------|---------------------------------|
| `pattern:x(?=y)`   | Позитивная опережающая     | `x`, если за ним следует `y`    |
| `pattern:x(?!y)`   | Негативная опережаюшая     | `x`, если за ним НЕ следует `y` |
| `pattern:(?<=y)x`  | Позитивная ретроспективная | `x`, если следует за `y`        |
| `pattern:(?<!y)x`  | Негативная ретроспективная | `x`, если НЕ следует за `y`     |

Опережающая проверка также может быть использована, чтобы отключить поиск с возвратом. Для чего нам это может понадобиться, вы узнаете в следующей главе.
