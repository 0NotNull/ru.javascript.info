# Квантификаторы +, *, ? и {n}

Давайте возьмём строку вида `+7(903)-123-45-67` и найдём все числа в ней. Но теперь нас интересуют не цифры по отдельности, а именно числа: `7, 903, 123, 45, 67`.

Число — это последовательность из 1 или более цифр `\d`. Чтобы отметить количество повторений, нам нужно указать *квантификатор*.

## Количество {n}

Самый простой квантификатор — это число в фигурных скобках: `pattern:{n}`.

Он добавляется к символу (или символу класса, или `[...]` набору символов и т.д.) и указывает сколько их нам нужно.

У него есть несколько продвинутых подходов, давайте посмотрим примеры:

Точное количество: `{5}`
: Паттерн `pattern:\d{5}` обозначает ровно 5 цифр, в точности как `pattern:\d\d\d\d\d`.

    Следующий пример находит пятизначное число:

    ```js run
    alert( "Мне 12345 лет".match(/\d{5}/) ); //  "12345"
    ```

    Мы можем добавить `\b`, чтобы исключить числа длинней: `pattern:\b\d{5}\b`.

Диапазон: `{3,5}`, от 3 до 5 
: Для того, чтобы найти числа c диапазоном от 3 до 5 знаков, мы можем указать границы в фигурных скобках: `pattern:\d{3,5}`

    ```js run
    alert( "Мне не 12, а 1234 года".match(/\d{3,5}/) ); // "1234"
    ```

    Мы можем не указывать последнее значение.

    Тогда паттерн `pattern:\d{3,}` найдет последовательность чисел длиной от `3` и более цифр:

    ```js run
    alert( "Мне не 12, а 345678 лет".match(/\d{3,}/) ); // "345678"
    ```

Давайте вернёмся к строке `+7(903)-123-45-67`.

Число это последовательность одной или более цифр. Поэтому паттерн будет `pattern:\d{1,}`:

```js run
let str = "+7(903)-123-45-67";

let numbers = str.match(/\d{1,}/g);

alert(numbers); // 7,903,123,45,67
```

## Короткие обозначения

Для самых часто востребованных квантификаторов есть короткие обозначения:

`+`
: Означает «один или более», то же что `{1,}`.

    Например, `pattern:\d+` находит числа:

    ```js run
    let str = "+7(903)-123-45-67";

    alert( str.match(/\d+/g) ); // 7,903,123,45,67
    ```

`?`
: Означает «ноль или один», то же что и `{0,1}`. По сути, делает символ необязательным.

    Например, паттерн `pattern:ou?r` найдёт `match:o` после которого, возможно, следует `match:u`, а затем `match:r`.

    Поэтому паттерн `pattern:colou?r` найдёт оба: `match:color` и `match:colour`:

    ```js run
    let str = "Следует писать color или colour?";

    alert( str.match(/colou?r/g) ); // color, colour
    ```

`*`
: Означает «ноль или более», то же что `{0,}`. То есть, символ может повторяться много раз или вообще отсутствовать.

    Например, паттерн `pattern:\d0*` находит цифру вместе со всеми нулями, которые идут за ней (но могут и не идти):

    ```js run
    alert( "100 10 1".match(/\d0*/g) ); // 100, 10, 1
    ```

    Сравните это с `'+'` (один или более):

    ```js run
    alert( "100 10 1".match(/\d0+/g) ); // 100, 10
    // 1 not matched, as 0+ requires at least one zero
    // 1 не подходит, т.к 0+ требует как минимум один ноль
    ```

## Ещё примеры

Эти квантификаторы принадлежат к числу самых важных «строительных блоков» для сложных регулярных выражений, поэтому мы рассмотрим ещё примеры.

Регулярное выражение с «десятичной дробью» (число с плавающей точкой): `pattern:\d+\.\d+`
: В действии:
    ```js run
    alert( "0 1 12.345 7890".match(/\d+\.\d+/g) ); // 12.345
    ```

Регулярное выражение для поиска «открывающего HTML-тега без атрибутов», например, `<span>` или `<p>`: `pattern:/<[a-z]+>/i`
: В действии:

    ```js run
    alert( "<body> ... </body>".match(/<[a-z]+>/gi) ); // <body>
    ```

    Это регулярное выражение ищет символ `pattern:'<'` за которым идут одна или более букв английского алфавита, а затем `pattern:'>'`.

Регулярное выражение для поиска «открывающего HTML-тега без атрибутов» (улучшенный вариант): `pattern:/<[a-z][a-z0-9]*>/i`
: Здесь регулярное выражение расширено: в соответствие со стандартом, HTML-тег может иметь символ цифры на любой позиции, кроме первой, например `<h1>`.

    ```js run
    alert( "<h1>Привет!</h1>".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>
    ```

Регулярное выражение для поиска «открывающего или закрывающего HTML-тега без атрибутов»: `pattern:/<\/?[a-z][a-z0-9]*>/i`
: В предыдущий паттерн мы добавили необязательный слеш `pattern:/?`. Этот символ понадобилось заэкранировать, чтобы JavaScript не принял его за конец шаблона.

    ```js run
    alert( "<h1>Привет!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>
    ```

```smart header="Чтобы регулярное выражение было точнее, нам часто приходится делать его сложнее"

В этих примерах мы видим общее правило: чем точнее регулярное выражение -- тем оно длиннее и сложнее.

Например, для HTML-тегов скорее всего подошло бы и более простое регулярное выражение: `pattern:<\w+>`.

...Но т.к класс `pattern:\w` означает любую английскую букву или цифру или `'_'`,  то для такого регэксп подойдут и не теги, например `match:<_>`. Однако он гораздо проще, чем регэксп `pattern:<[a-z][a-z0-9]*>`, но менее точный.

Подойдёт ли нам `pattern:<\w+>` или нужно использовать `pattern:<[a-z][a-z0-9]*>`?

В реальной жизни допустимы оба варианта. Ответ на подобные вопросы зависит от того, насколько реально важна точность и насколько потом будет сложно или не сложно отфильтровать лишние совпадения.
```
