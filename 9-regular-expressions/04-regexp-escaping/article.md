
# Экранирование специальных символов

Как мы уже видели, обратная косая черта `"\"` используется для обозначения классов символов. Это специальный символ в регулярных выражениях (как и в обычных строках).

Есть и другие специальные символы, которые имеют особое значение в регулярном выражении. Они используются для более сложных поисковых конструкций. Вот полный перечень этих символов: `pattern:[ \ ^ $ . | ? * + ( )`.

Не надо пытаться запомнить этот список -- скоро мы разберемся с каждым из них по отдельности, и вы выучите их наизусть автоматически.

## Экранирование символов

Допустим, мы хотим найти буквально точку. Не "любой символ", а именно точку.

Чтобы использовать специальный символ как обычный, добавьте к нему обратную косую черту: `pattern:\.`.

Это называется "экранирование символа".

К примеру:
```js run
alert( "Глава 5.1".match(/\d\.\d/) ); // 5.1 (совпадение!)
alert( "Глава 511".match(/\d\.\d/) ); // null ("\." - ищет обычную точку)
```

Круглые скобки так же являются специальными символами, поэтому, если мы хотим использовать именно их, мы должны указывать `pattern:\(`. В приведенном ниже примере ищется строка `"g()"`:

```js run
alert( "function g()".match(/g\(\)/) ); // "g()"
```

Если мы ищем обратную косую `\`, это специальный символ как в обычных строках, так и в регулярных выражениях, поэтому мы должны удвоить его.

```js run
alert( "1\\2".match(/\\/) ); // '\'
```

## Косая черта (слеш)

Символ косой черты `'/'` не является специальным символом, но в JavaScript он используется для открытия и закрытия регулярного выражения: `pattern:/...pattern.../`, поэтому мы должны экранировать его.

Вот как выглядит поиск самой косой черты `'/'`:

```js run
alert( "/".match(/\//) ); // '/'
```

С другой стороны, если мы не используем короткую запись `/.../`, а создаем регулярное выражение, используя `new RegExp`, тогда нам не нужно экранировать его:

```js run
alert( "/".match(new RegExp("/")) ); // '/'
```

## new RegExp

Если мы создаем регулярное выражение с помощью `new RegExp`, то нам не нужно учитывать `/`, но нужно соблюдать другие экранирования.

Например, рассмотрим это:

```js run
let reg = new RegExp("\d\.\d");

alert( "Глава 5.1".match(reg) ); // null
```

Это работает с `pattern:/\d\.\d/`, но не работает с `new RegExp("\d\.\d")`, почему?

Причина в том, что обратные косые "употребляются" как строка. Помните, что обычные строки имеют свои специальные символы, такие как `\n`, и для экранирования используется обратная косая.

Пожалуйста, посмотрите, что на самом деле означает "\d\.\d":

```js run
alert("\d\.\d"); // d.d
```

Кавычки "употребляют" обратные косые и интерпретируют их по своему усмотрению, например:

- `\n` -- становится символом перевода строки,
- `\u1234` -- становится символом Юникода с указанным номером,
- ...А когда нет особого значения: как например для `\d` или`\z`, обратная косая просто удаляется.

Таким образом, вызов `new RegExp` получает строку без обратной косой черты. Вот почему это не работает!

Чтобы исправить это, нам нужно удвоить обратную косую черту, потому что кавычки превращают `\\` в `\`:

```js run
*!*
let regStr = "\\d\\.\\d";
*/!*
alert(regStr); // \d\.\d (теперь правильно)

let reg = new RegExp(regStr);

alert( "Глава 5.1".match(reg) ); // 5.1
```

## Итого

- Для поиска специальных символов `pattern:[ \ ^ $ . | ? * + ( )` в буквальном смысле, нам нужно добавить перед ними `\` ("экранировать их").
- Нам также нужно экранировать `/`, если мы используем `pattern:/.../` (но не `new RegExp`).
- При передаче строки в `new RegExp` нам нужно удвоить обратную косую черту `\\` для экранирования специальных символов, потому что строки будут использовать одну из них для своих целей.
