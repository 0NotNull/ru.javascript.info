# Длительные опросы

Длительный опрос - это самый простой способ получить постоянное соединение с сервером, не используя при этом никаких специфических протоколов (как WebSocket или Server Side Events).

Даный способ очень прост в реализации и хорошо подходит для многих задач.

## Частые опросы

Опрос (polling) - это самый простой способ получить новую информацию от сервера.

То есть, это периодические запросы на сервер: "Привет, я здесь, у вас есть какая-нибудь информация для меня?". Например, раз в 10 секунд.

В ответ сервер во-первых помечает у себя, что клиент онлайн, а во-вторых посылает сообщение, в котором в специальном формате содержится весь пакет событий, накопившихся к данному моменту.

Это работает, но есть и недостатки:
1. Сообщения передаются с задержкой до 10 секунд.
2. Даже если сообщений нет, сервер атакуют запросы каждые 10 секунд. С точки зрения производительности, это довольно большая нагрузка для бэкэнда.

Так что, если речь идет о очень маленьком сервисе, подход может оказаться жизнеспособным.

Но в целом, он нуждается в улучшении.

## Длительные опросы

Длительные опросы - лучший способ взаимодействия с сервером.

Они также очень просты в реализации и сообщения доставляются без задержек.

Как это происходит:

1. Запрос отправляется на сервер.
2. Сервер не закрывает соединение, пока не получит сообщение.
3. Когда появляется сообщение - сервер отвечает на запрос, посылая данные.
4. Браузер немедленно делает новый запрос.

Для данного метода ситуация, когда браузер отправил запрос и удерживает соединение с сервером, ожидая ответа, является стандартной. Соединение прерывается только доставкой сообщений.

![](long-polling.png)

Даже если соединение будет потеряно, скажем, из-за сетевой ошибки, браузер немедленно посылает новый запрос.

Примерный код клиентской части:

```js
async function subscribe() {
  let response = await fetch("/subscribe");

  if (response.status == 502) {
    // Тайм-аут соединения; происходит, когда соединение ожидало слишком долго.
    // давайте восстановим связь
    await subscribe();
  } else if (response.status != 200) {
    // Показать ошибку
    showMessage(response.statusText);
    // Подключиться снова через секунду.
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();
  } else {
    // Получить сообщение
    let message = await response.text();
    showMessage(message);
    await subscribe();
  }
}

subscribe();
```

Функция `subscribe()` делает запрос, затем ждет ответа, обрабатывает его и снова вызывает сама себя.

```warn header="Сервер должен поддерживать множественные ожидающие подключения."
Архитектура сервера должна быть способна работать со многими ожидающими подключениями.

Некоторые серверные архитектуры запускают отдельный процесс для каждого соединения. Для большого количества соединений будет столько же процессов, и каждый процесс занимает значительный обьём памяти. Так много соединений просто поглотят всю память.

Часто такая проблема возникает с бэкендами, написанными на PHP или Ruby, но технически дело не в языке, а скорее в реализации.

Бэкенды, написанные с помощью Node.js, обычно не имеют таких проблем.
```

## Демо: чат

Демо:

[codetabs src="longpoll" height=500]

## Область применения

Длительные опросы прекрасно работают с редкими сообщениями.

Если сообщения приходят очень часто, то схема приёма-отправки сообщений, приведённая выше, становится "пилой".

Каждое сообщение - это отдельный запрос, поставляемый с заголовками, издержками аутентификации и так далее.

Поэтому в данном случае предпочтительнее использовать другой метод, такой как [Websocket](info:websocket) или [Server Sent Events](info:server-sent-events).
