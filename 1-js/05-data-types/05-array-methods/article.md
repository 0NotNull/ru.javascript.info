# Методы массивов

Массивы предоставляют множество методов. Чтобы было проще, в этой главе они разбиты на группы.

## Добавление/удаление элементов

Мы уже знаем методы, которые добавляют и удаляют элементы из начала или конца:

- `arr.push(...items)` -- добавляет элементы в конец,
- `arr.pop()` -- извлекает элемент из конца,
- `arr.shift()` -- извлекает элемент из начала,
- `arr.unshift(...items)` -- добавляет элементы в начало.

Есть и другие.

### splice

Как удалить элемент из массива?

Так как массивы являются объектами, то для удаления ключа можно воспользоваться обычным `delete`:

```js run
let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"

alert( arr[1] ); // undefined

// теперь arr = ["I",  , "home"];
alert( arr.length ); // 3
```

Вроде бы элемент был удалён, но при проверке оказывается что массив всё ещё имеет 3 элемента `arr.length == 3`.

Это нормально, потому что всё что делает `delete obj.key`, это удаляет значение с помощью `key`. 
Это подходит для объектов, но для массивов мы обычно хотим, чтобы остальные элементы смещались и занимали освободившееся место. 
Мы ожидаем, что массив станет короче.

Для этого нужно использовать специальные методы.

??? Метод [arr.splice(str)](mdn:js/Array/splice) – это универсальный раскладной нож для работы с массивами. Умеет все: добавлять, удалять и заменять элементы.

Его синтаксис:

```js
arr.splice(index[, deleteCount, elem1, ..., elemN])
```

Удалить `deleteCount` элементов, начиная с номера `index`, а затем вставить `elem1, ..., elemN` на их место. Возвращает массив из удалённых элементов.

Этот метод проще всего понять, рассмотрев примеры.

Начнём с удаления:

```js run
let arr = ["Я", "изучаю", "JavaScript"];

*!*
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
*/!*

alert( arr ); // осталось ["Я", "JavaScript"]
```

Легко, правда? Начиная с позиции `1`, он убрал `1` элемент.

В следующем примере мы удалим 3 элемента и заменим их двумя другими.

```js run
let arr = [*!*"Я", "изучаю", "JavaScript",*/!* "прямо", "сейчас"];

// удалить 3 первых элемента и удалить их другими
arr.splice(0, 3, "Давай", "танцевать");

alert( arr ) // теперь [*!*"Давай", "танцевать"*/!*, "прямо", "сейчас"]
```

Здесь видно, что splice возвращает массив из удаленных элементов:

```js run
let arr = [*!*"Я", "изучаю",*/!* "JavaScript", "прямо", "сейчас"];

// удалить 2 первых элемента
let removed = arr.splice(0, 2);

alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов
```

Метод `splice` также может вставлять элементы без удаления, для этого достаточно установить `deleteCount` в `0`:

```js run
let arr = ["Я", "изучаю", "JavaScript"];

// с позиции 2
// удалить 0
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
```

````smart header="Negative indexes allowed"
В этом и в других методах для массивов допускается использование отрицательного номера позиции, которая в этом случае отсчитывает элементы с конца:

```js run
let arr = [1, 2, 5];

// начиная с индекса -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
```
````

### slice

Метод [arr.slice](mdn:js/Array/slice) намного проще чем похожий на него `arr.splice`

Его синтаксис:

```js
arr.slice(start, end)
```

Он возвращает новый массив, который содержит в себе все элементы начиная со `"start"` и заканчивая `"end"` (не включая `"end"`).
Оба индекса `start` и `end` могут быть отрицательными. В этом случае отсчёт будет осуществляться с конца массива.

Это работает так же как и `str.slice`, но делает подмассивы вместо подстрок

Например:

```js run
let str = "test";
let arr = ["t", "e", "s", "t"];

alert( str.slice(1, 3) ); // es
alert( arr.slice(1, 3) ); // e,s

alert( str.slice(-2) ); // st
alert( arr.slice(-2) ); // s,t
```

### concat

Метод [arr.concat](mdn:js/Array/concat) объединяет массив с другими массивами и/или элементами.

Его синтаксис:

```js
arr.concat(arg1, arg2...)
```

Он принимает любое количество аргументов -- которые могут быть массивами или значениями.

В результате мы получаем новый массив включающий в себя элементы из `arr`, а также `arg1`, `arg2` и так далее...

Если аргумент — массив, или имеет свойство `Symbol.isConcatSpreadable`, то все его элементы копируются. В противном случае скопируется сам аргумент.

Например:

```js run
let arr = [1, 2];

// объединить arr с [3,4]
alert( arr.concat([3, 4])); // 1,2,3,4

// объединить arr с [3,4] и [5,6]
alert( arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6

// объединить arr с [3,4], потом добавить значение 5 и 6
alert( arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6
```

Как правило, он только копирует элементы из массивов («раскладывает» их). Другие объекты, даже если они выглядят как массивы, добавляются как есть:

```js run
let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
//[1, 2, arrayLike]
```

... Но если массивоподобный объект имеет свойство `Symbol.isConcatSpreadable`, вместо него добавляются его элементы:

```js run
let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  1: "ещё",
*!*
  [Symbol.isConcatSpreadable]: true,
*/!*
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
```

## Перебор: forEach

Метод [arr.forEach](mdn:js/Array/forEach) позволяет запускать функцию для каждого элемента массива.

Его синтаксис:
```js
arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});
```

Например этот код покажет каждый элемент массива:

```js run
// Вызов alert для каждого элемента
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
```

А этот более подробно опишет их позиции в заданном массиве:

```js run
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} имеет позицию ${index} в ${array}`);
});
```

Результат функции (если она что-то возвращает) отбрасывается и игнорируется.


## Поиск в массиве

Это методы поиска чего-либо в массиве.

### indexOf/lastIndexOf и includes

Методы [arr.indexOf](mdn:js/Array/indexOf), [arr.lastIndexOf](mdn:js/Array/lastIndexOf) и [arr.includes](mdn:js/Array/includes) имеют одинаковый синтаксис и делают по сути то же самое что и их строковые аналоги, но работают с элементами вместо символов:

- `arr.indexOf (item, from)` ищет `item`, начиная с индекса` from`, и возвращает индекс, в котором он был найден, в противном случае `-1`.
- `arr.lastIndexOf (item, from)` - то же самое, но ищет справа налево.
- `arr.includes (item, from)` - ищет `item`, начиная с индекса` from`, возвращает `true`, если найдёт.

Например:

```js run
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```

Обратите внимание, что методы используют сравнение `===`. Таким образом, если мы ищем `false`, он находит именно `false`, а не ноль.

Если мы хотим проверить наличие включений и не хотим знать точный индекс, тогда предпочтительным является `arr.include`.

Кроме того, очень незначительным отличием `include` является то, что он правильно обрабатывает` NaN`, в отличие от `indexOf / lastIndexOf`:

```js run
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === равенство не работает для NaN)
alert( arr.includes(NaN) );// true (верно)
```

### find и findIndex

Представьте, что у нас есть массив объектов. Как нам найти объект с определенным условием?

Здесь пригодится метод [arr.find](mdn:js/Array/find).

Его синтаксис таков:
```js
let result = arr.find(function(item, index, array) {
  // если возвращается true, метод возвращает элемент и итерация останавливается
  // для ложного сценария возвращает undefined
});
```

Функция вызывается многократно для каждого элемента массива:

- `item` это элемент.
- `index` это его индекс.
- `array` это сам массив.

Если функция возвращает `true`, поиск останавливается, возвращается `item`. Если ничего не найдено, возвращается `undefined`.

Например, у нас есть массив пользователей, каждый из которых имеет поля `id` и` name`. Давайте найдем того, кто с `id == 1`:

```js run
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася
```

В реальной жизни массивы объектов обычное дело, поэтому метод `find` очень полезен.

Обратите внимание, что в данном примере мы предоставляем `find` функцию` item => item.id == 1` с одним аргументом. Другие аргументы этой функции используются редко.

Метод [arr.findIndex](mdn:js/Array/findIndex) по сути тот же самое, но он возвращает индекс, в на котором был найден элемент, а не сам элемент, и возвращается `-1`, когда ничего не найдено.

### filter

Метод `find` ищет один (первый) элемент, который заставляет функцию возвращать` true`.

Если их может быть много, мы можем использовать [arr.filter(fn)](mdn:js/Array/filter).

Синтаксис похож на `find`, но фильтр продолжает повторяться для всех элементов массива, даже если` true` уже возвращено:

```js
let results = arr.filter(function(item, index, array) {
  // Если true — элемент добавляется к результату и перебор продолжается
  // Возвращает пустой массив в случае если все итерации оказались ложными 
});
```

Например:

```js run
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

// возвращает массив первых двух пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

## Преобразование массива

Этот раздел о методах преобразования или переупорядочения массива.


### map

Метод [arr.map](mdn:js/Array/map) является одним из наиболее полезных и часто используемых.

Синтаксис:

```js
let result = arr.map(function(item, index, array) {
  // возвращает новое значение вместо элемента
})
```

Он вызывает функцию для каждого элемента массива и возвращает массив результатов.

Например, здесь мы преобразуем каждый элемент в его длину:

```js run
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

### sort(fn)

Метод [arr.sort](mdn:js/Array/sort) сортирует массив *на месте*.

Например:

```js run
let arr = [ 1, 2, 15 ];

// метод переупорядочивает содержимое arr (и возвращает его)
arr.sort();

alert( arr );  // *!*1, 15, 2*/!*
```

Не заметили ничего странного в этом примере?

Порядок стал `1, 15, 2`. Неправильно. Но почему?

**По умолчанию элементы сортируются как строки.**

Это произошло потому, что все элементы преобразуются в строки, а затем сравниваются. Таким образом, применяется лексикографическое упорядочение и на самом деле `"2" > "15"`.

Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию с двумя аргументами в качестве аргумента `arr.sort ()`.

Функция должна работать так:
```js
function compare(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}
```

Например:

```js run
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

*!*
arr.sort(compareNumeric);
*/!*

alert(arr);  // *!*1, 2, 15*/!*
```

Теперь всё работает как надо.

Давайте отойдем в сторону и подумаем, что же происходит. Упомянутый выше массив `arr` может быть массивом чего угодно, верно? Он может содержать числа, строки, элементы HTML или что-то еще. У нас есть набор *чего-то*. Чтобы отсортировать его, нам нужна *упорядочивающая функция*, которая знает, как сравнивать ее элементы. По умолчанию элементы сортируются как строки.

Метод `arr.sort(fn)` имеет встроенную реализацию алгоритма сортировки. Нам не нужно заботиться о том, как это на самом деле работает (в большинстве случаев это оптимизированная [quicksort](https://en.wikipedia.org/wiki/Quicksort)). Она будет проходить по массиву, сравнивать его элементы с помощью предоставленной функции и переупорядочивать их, все, что нам нужно, это предоставить `fn`, которая выполняет сравнение.

Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются -- ничто не мешает нам вывести их на экран:

```js run
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
});
```

В процессе работы алгоритм может сравнивать элемент по нескольку раз, но он всё равно старается сделать как можно меньше сравнений.


````smart header="Функция сравнения может вернуть любое число"
На самом деле, функция сравнения требуется только для возврата положительного числа, чтобы сказать "больше" и отрицательного числа, чтобы сказать "меньше".

Это позволяет писать более короткие функции:

```js run
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // *!*1, 2, 15*/!*
```
````

````smart header="Лучше использовать стрелочные функции"
Помните [arrow functions](info:function-expressions-arrows#arrow-functions)? Мы можем использовать их здесь для того что бы сортировка выглядела более аккуратной:

```js
arr.sort( (a, b) => a - b );
```

Это работает точно так же, как и другая, более длинная версия выше.
````

### reverse

Метод [arr.reverse](mdn:js/Array/reverse) меняет порядок элементов в `arr`.

Например:

```js run
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

Он также возвращает массив `arr` с изменённым порядком элементов.

### split и join

Ситуация из реальной жизни. Мы пишем сервис отсылки сообщений и посетитель вводит имена тех, кому его отправить: `Вася, Петя, Маша`.    Но нам-то гораздо удобнее работать с массивом имен, чем с одной строкой. Как это сделать?

Метод [str.split(delim)](mdn:js/String/split) именно это и делает. Он разбивает строку на массив по заданному разделителю `delim`.

В примере ниже таким разделителем является строка из запятой и пробела.

```js run
let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
  alert( `Вам сообщение ${name}.` ); // Вам сообщение Вася (и другие имена)
}
```

У метода `split` есть необязательный второй числовой аргумент -- ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен. На практике это редко используется:

```js run
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```

````smart header="Разбивка по буквам"
Вызов `split(s)` с пустой `s` разбил бы строку на массив букв:

```js run
let str = "тест";

alert( str.split('') ); // т,е,с,т
```
````

Вызов [arr.join(separator)](mdn:js/Array/join) делает в точности противоположное `split`. Он создаёт строку из елементов `arr` используя `separator` как разделитель.

Например:

```js run
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';');

alert( str ); // Bilbo;Gandalf;Nazgul
```

### reduce/reduceRight

Если нам нужно перебрать массив -- мы можем использовать `forEach`,` for` или `for..of`.

Если нам нужно перебрать массив и возвратить данные для каждого элемента -- мы используем `map`.

Методы [arr.reduce](mdn:js/Array/reduce) и [arr.reduceRight](mdn:js/Array/reduceRight) похожы на методы выше, но они немного сложнее.
Они используются для вычисления на основе массива какого-нибудь единого значения.

Синтаксис:

```js
let value = arr.reduce(function(previousValue, item, index, array) {
  // ...
}, initial);
```

К каждому элементу применяется функция. Аргументы, начиная со второго, уже знакомы нам:

- `item` -- текущий элемент массива.
- `index` -- его позиция.
- `array` -- сам массив.

Не так давно мы видели их в `forEach / map`. Но есть еще один аргумент:

- `previousValue` -- это результат предыдущего вызова функции, а `initial` нужен для первого вызова.

Этот метод проще всего понять, рассмотрев пример.

Тут мы получим сумму всех элементов массива всего одной строкой:

```js run
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```

Здесь мы использовали наиболее распространенный вариант `reduce`, который использует только 2 аргумента.

Давайте детальнее разберём как это работает.

1. При первом запуске `sum` -- это начальное значение (последний аргумент `reduce`), равен `0`, а `current` -- первый элемент массива, равен `1`. Таким образом, результат равен `1`.
2. При втором запуске, `sum = 1`, и к нему мы добавляем второй элемент массива (`2`).
3. На 3-м запуске, `sum = 3`, к которому мы добавлем следующий элемент, и так далее...

Поток вычислений получается такой:

![](reduce.png)

В виде таблицы где каждая строка – вызов функции на очередном элементе массива:

|   |`sum`|`current`|`result`|
|---|-----|---------|---------|
|первый вызов|`0`|`1`|`1`|
|второй вызов|`1`|`2`|`3`|
|третий вызов|`3`|`3`|`6`|
|четвёртый вызов|`6`|`4`|`10`|
|пятый вызов|`10`|`5`|`15`|


Как видно, результат предыдущего вызова передаётся в первый аргумент следующего.

Также мы можем опустить начальное значение:

```js run
let arr = [1, 2, 3, 4, 5];

// убрано начальное значение (нет 0 в конце)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
```

Результат – точно такой же! Это потому, что при отсутствии `initial` в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.

Таблица вычислений будет такая же, за вычетом первой строки.

Но такое использование требует крайней осторожности. Если массив пуст, то вызов `reduce` без начального значения выдаст ошибку.

Вот пример:

```js run
let arr = [];

// Error: Reduce of empty array with no initial value
// если бы существовало начальное значение, reduce вернул бы его для пустого массива.
arr.reduce((sum, current) => sum + current);
```


Поэтому рекомендуется всегда указывать начальное значение.

Метод [arr.reduceRight](mdn:js/Array/reduceRight) работает аналогично, но идёт по массиву справа-налево.


## Array.isArray

Массивы не образуют отдельный тип языка. Они основаны на объектах.

Поэтому `typeof` не может отличить простой объект от массива:

```js run
alert(typeof {}); // объект
alert(typeof []); // то же объект
```

...Но массивы используются насколько часто, что для этого придумали специальный метод: [Array.isArray(value)](mdn:js/Array/isArray). Он возвращает `true`, если` value` массив, и `false` если нет.

```js run
alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
```

## Большинство методов поддерживают "thisArg"

Почти все методы массива, которые вызывают функции -- такие как `find`, `filter`, `map`, за исключением метода `sort`, принимают необязательный параметр `thisArg`.

Этот параметр не объяснялся выше, так как очень редко используется, но для наиболее полного понимания темы мы обязаны его рассмотреть.

Вот полный синтаксис этих методов:

```js
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg - это необязательный последний аргумент
```

Значение параметра `thisArg` становится `this` для `func`.

Например, вот тут мы используем метод объекта как фильтр и `thisArg` нам очень поможет:

```js run
let user = {
  age: 18,
  younger(otherUser) {
    return otherUser.age < this.age;
  }
};

let users = [
  {age: 12},
  {age: 16},
  {age: 32}
];

*!*
// найти всех пользователей моложе чем заданный
let youngerUsers = users.filter(user.younger, user);
*/!*

alert(youngerUsers.length); // 2
```

В вызове выше, мы используем `user.younger` как фильтр а также отдаём `user` в качестве контекста для него. Если бы мы не предоставляли контекст, 
`users.filter(user.younger)` вызвал бы `user.younger` как отдельную функцию, с `this = undefined`. Это означало бы мгновенную ошибку.

## Итого

Шпаргалка методов массива:

- Для добавления/удаления элементов:  
  - `push (... items)` -- добавляет элементы в конец,
  - `pop()` -- извлекает элемент с конца,
  - `shift()` -- извлекает элемент с начала,
  - `unshift(... items)` -- добавляет элементы в начало.
  - `splice(pos, deleteCount, ... items)` -- по индексу `pos` удаляет` deleteCount` элементы и вставляет `items`.
  - `slice(start, end)` -- создает новый массив, копируя в него элементы с позиции `start` до `end` (не включая `end`).
  - `concat(... items)` -- возвращает новый массив: копирует все члены текущего массива и добавляет к нему `items`. Если какой-либо из `items` является массивом, тогда берутся его элементы.  

- Для поиска среди элементов:
  - `indexOf/lastIndexOf(item, pos)` -- ищет `item`, начиная с позиции `pos` и возвращает его индекс, или `-1` если ничего не найдено.
  - `includes(value)` -- возвращает `true`, если массив имеет значение` value`, в противном случае `false`.
  - `find/filter(func)` -- фильтрует элементы через функцию и отдаёт первые/все значения, которые при прохождении через неё возвращают `true`.
  - `findIndex` похож на `find`, но возвращает индекс вместо значения.
  
- Для перебора элементов:
  - `forEach(func)` -- вызывает `func` для каждого элемента. Ничего не возвращает.

- Для преобразования массива:
  - `map(func)` -- создаёт новый массив из результатоы вызова `func` для каждого элемента.
  - `sort(func)` -- сортирует массив на месте, а потом возвращает его.
  - `reverse()` -- инвертирует массив на месте, а потом возвращает его.
  - `split/join` -- преобразует строку в массив и обратно.
  - `reduce(func, initial)` -- вычисляет одно значение из всего массива, вызывая `func` для каждого элемента и передавая промежуточный результат между вызовами.

- Дополнительно:
  - `Array.isArray(arr)` проверяет является ли `arr` массивом.

Обратите внимание, что методы `sort`,` reverse` и `splice` изменяют исходный массив.

Изученных нами методов достаточно в 99% случаях, но существуют и другие.

- [arr.some(fn)](mdn:js/Array/some)/[arr.every(fn)](mdn:js/Array/every) проверяет массив.

  Функция `fn` вызывается для каждого элемента массива аналогично `map`. Если какие-либо/все результаты являются `true`, он возвращает` true`, иначе `false`.

- [arr.fill(value, start, end)](mdn:js/Array/fill) -- заполняет массив повторяющимся `value` начиная с индекса `start` до `end`.

- [arr.copyWithin(target, start, end)](mdn:js/Array/copyWithin) -- копирует свои элементы начиная со `start` и заканчивая `end` в *собственную*, позицию `target` (перезаписывает существующие).

Полный список см. в [руководстве](mdn:js/Array).

На первый взгляд может показаться, что существует очень много разных методов, которые довольно сложно запомнить. Но на самом деле это гораздо проще, чем кажется.

Поближе ознакомьтесь со шпаргалкой представленной выше, а затем, чтобы попрактиковаться, решите задачи предложенные в данной главе. Так вы получите необходимый опыт в правильном использовании методов массива.

Всякий раз, когда вам нужно что-то сделать с массивом, и вы не знаете, как это сделать -- приходите сюда, посмотрите на таблицу и найдите правильный метод. Примеры помогут вам всё сделать правильно и вскоре вы автоматически запомните методы без особых усилий с вашей стороны.
