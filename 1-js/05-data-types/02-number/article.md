# Числа

Все числа в JavaScript хранятся в 64-битном формате [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985), известные также как числа с двойной точностью.

Давайте повторим и подробно узнаем, как работать с числами в JavaScript.

## Способы записи числа

Представьте, что нам надо записать число 1 миллиард. Самый очевидный путь:

```js
let billion = 1000000000;
```

Но в реальной жизни мы обычно опускаем запись множества нулей, так как можно легко ошибиться. Укороченная запись может выглядень как `"1млрд"` или `"7.3млрд"` для 7 миллиардов 300 миллионов. Такой принцип работает для всех больших чисел.

В JavaScript можно использовать букву `"e"`, чтобы укоротить запись числа. Она добавляется к числу и заменяет указанное количество нулей:

```js run
let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей

alert( 7.3e9 );  // 7.3 миллиардов (7,300,000,000)
```

Другими словами, `"e"` производит операцию умножения числа на 1 с указанным количеством нулей.

```js
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
```


Сейчас давайте запишем что-нибудь очень маленькое. К примеру, 1 микросекунду (одна милионная секунды):

```js
let ms = 0.000001;
```

Чтобы записать микросекунду в укороченном виде нам поможет `"e"`.

```js
let ms = 1e-6; // шесть нулей, слева от 1
```

Если мы подсчитаем количество нулей `0.000001`, их будет 6. Естественно, верная запись `1e-6`.  

Другими словами, отрицательное число после `"e"` подразумевает деление на 1 с указанным количеством нулей:

```js
// -3 делится на 1 с 3 нулями
1e-3 = 1 / 1000 (=0.001)

// -6 делится на 1 с 6 нулями
1.23e-6 = 1.23 / 1000000 (=0.00000123)
```

### Шестнадцатеричные, двоичные и восьмеричные числа

[Шестнадцатеричные](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D1%81%D1%82%D0%BD%D0%B0%D0%B4%D1%86%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F) числа широко используются в JavaScript для представления цветов, кодировки символов и многое другое. Естественно, есть короткий стиль записи: `0x`, после которого указывается число.

Например:

```js run
alert( 0xff ); // 255
alert( 0xFF ); // 255 (тоже самое, регистр не имеет значения)
```

Не так часто используются двоичные и восьмеричные числа, но они также поддерживаются `0b` для двоичных и `0o` для восьмеричных:


```js run
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричныая форма записи числа 255

alert( a == b ); // истина, с двух сторон число 255
```

Есть только 3 системы счисления с такой поддрежкой. Для других систем счисления мы рекомендуем использовать функцию `parseInt` (подробнее рассмотрим позже, в этой главе).

## toString(base)

Метод `num.toString(base)` возвращает строковое предстваление числа `num` в системе счисления `base`.

Например:
```js run
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

`base` может варьироваться от `2` до `36` (по умолчанию `10`).

Часто используемые:

- **base=16** для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть `0..9` или `A..F`.
- **base=2** — обычно используется для отладки побитовых операций, цифры `0` или `1`.
- **base=36** максимум, цифры могут быть `0..9` или `A..Z`. Используется весь латинский алфавит для представления числа. Смешно, но можно использовать `36` разрядную систему счисления, когда мы хотим укоротить отображение слишком большого числового идентификатора, например можно сделать укороченную ссылку. Можно просто преобразовать в `36` систему счисления:

    ```js run
    alert( 123456..toString(36) ); // 2n9c
    ```

```warn header="Two dots to call a method"
Внимание! Две точки в `123456..toString(36)` это не опечатка. Если нам надо использовать метод непосредственно на числе, как `toString` в примере выше, то нам надо поставить две точки `..` после числа.

Если мы поставим одну точку: `123456.toString(36)`, тогда это будет ошибкой, поскольку синтаксис JavaScript предполагает, что начинается десятичная часть после первой точки. А если поставить две точки, то JavaScript понимает, что десятичная часть отсутствует и начинается метод.

Также, можно записать как `(123456).toString(36)`.
```

## Округление

Одна из часто используемых операций при работе с числами - это округление.

В JavaScript есть несколько встренных функций для работы с округлением:

`Math.floor`
: Округление в меньшую сторону: `3.1` становится `3`, и `-1.1` становится `-2`.

`Math.ceil`
: Округление в большую сторону: `3.1` становится `4`, и `-1.1` становится `-1`.

`Math.round`
: Округление до ближайшего целого: `3.1` становится `3`, `3.6` становится `4` и `-1.1` становится `-1`.

`Math.trunc` (не поддерживается в Internet Explorer)
: Производит удаление дробной части без округления: `3.1` становится `3`, `-1.1` становится `-1`.

Ниже представлена таблица с различиями между функциями округления:

|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
|---|---------|--------|---------|---------|
|`3.1`|  `3`    |   `4`  |    `3`  |   `3`   |
|`3.6`|  `3`    |   `4`  |    `4`  |   `3`   |
|`-1.1`|  `-2`    |   `-1`  |    `-1`  |   `-1`   |
|`-1.6`|  `-2`    |   `-1`  |    `-2`  |   `-1`   |


Эти функции охватывают все возможные способы обработки десятичной части. Что если нам надо округлить число до `n-ого` количества цифр в дробной части?

Например, у нас есть `1.2345` и мы хотим округлить число до 2-х знаков после запятой, оставить только `1.23`.

Есть два пути решения:

1. Умножить и разделить.

    Например, чтобы округлить число до второго знака после запятой, мы можем умножить число на `100`, вызвать функцию округления и разделить обратно.
    ```js run
    let num = 1.23456;

    alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
    ```

2. Метод [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) округляет число до `n` знаков после запятой и возвращает строковое представление результата.

    ```js run
    let num = 12.34;
    alert( num.toFixed(1) ); // "12.3"
    ```

    Округляет значение до ближайшего вверх или вниз, аналогичный методу `Math.round`:

    ```js run
    let num = 12.36;
    alert( num.toFixed(1) ); // "12.4"
    ```

    Обратите внимание, что результатом `toFixed` является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:

    ```js run
    let num = 12.34;
    alert( num.toFixed(5) ); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой
    ```

    Мы можем преобразовать полученное значение в число, используя унарный оператор `+` или `Number()`, используя унарный оператор: `+num.toFixed(5)`.

## Неточные вычисления

Внутри JavaScript число представлено в виде 64-битного формата [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985). Итак, для хранения числа используется 64 бита: 52 из них используется для хранения цифр, 11 из них для хранения положения десятичной точки (если число целое, то хранится 0), и один бит отведен на хранения знака.

Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернет бесконечность:

```js run
alert( 1e500 ); // Infinity
```

Наиболее часто встречающаяся ошибка при работе с числами в JavaScript - это потеря точности.

Ниже представлено ложное утверждение:

```js run
alert( 0.1 + 0.2 == 0.3 ); // *!*false*/!*
```

Да-да, если мы проверим сумму между `0.1` и `0.2`, то получим `0.3`, но утверждение `false`.

Странно! Что тогда, если не `0.3`?

```js run
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

Ой! Здесь гораздо больше последствий, чем просто некорректное сравнение. Представьте, вы делаете интернет-магазин и посетители формируют заказ из 2-х позиций за `$0.10` и `$0.20`. Итоговый заказ будет `$0.30000000000000004`. Это будет сюрпризом для всех.

Но почему это происходит?

Число хранится в памяти в бинарной форме, последовательность единиц и нулей. Но дроби как `0.1`, `0.2`, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двичной форме.

Что такое `0.1` на самом деле? Это 1 деленное на 10 `1/10`, одна десятая. В десятичной системе счисления такие числа легко представить. Например, одна третья: `1/3`. В Javascript становится бесконечной дробью `0.33333(3)`.

Таким образом, деление на `10` гарантированно хорошо работает в десятичной системе, но деление на `3` нет. По той же причине и в двоичной системе счисления, деление на `2` гарантированно работает, а `1/10` становится бесконечной дробью.

В JavaScript нет возможности для хранения точных значений *0.1* или *0.2*, используя двоичную систему, точно также, как и нет возможности хранить одну третью в десятичной системе счисления.

Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа. Эти правила округления обычно не позволяют нам увидеть эту "крошечную потерю точности", поэтому число отображается как `0.3`. Но неточность сохраняется.

Пример:
```js run
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

И когда мы суммируем 2 числа, их "неточности" тоже суммируются.

Вот почему `0.1 + 0.2` это не совсем `0.3`.

```smart header="Not only JavaScript"
Ради справедливости заметим, что ошибка в точности вычислений для чисел с плавающей точкой сохраняется в любом другом языке, где используется формат IEEE 754, включая Java, C, PHP, Ruby, Perl, Python.
```

Можно ли обойти проблему? Конечно, наиболее надежный способ - это округлить результат используя метод [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed):

```js run
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

Помните, что метод `toFixed` всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр в десятичной части. Также, это удобно для форматирования цен в интернет-магазине `$0.30`. В других случаях можно использовать унарный оператор `+`, чтобы преобразовать строку в число:

```js run
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```

Также, можно временно умножить число на 100 (или на большее), чтобы привести его к целому, выполнить математические действия, и после разделить назад. Суммируя целые числа, мы уменьшаем погрешность, но она все равно появляется при финальном делении:

```js run
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

Таким образом, метод умножения/деления уменьшает погрешность, но полностью ее не решает.

Иногда можно попробовать полностью отказаться от дробей. Например, если мы в нашем интернет-магазине начнем использовать центы вместо долларов. Но что будет, если мы применим скидку 30%? На практике нам не получится полностью уклониться от дроби. Просто используйте округление, чтобы отрезать "хвосты", когда надо.

````smart header="The funny thing"
Забавный пример:

```js run
// Привет! Я – число, растущее само по себе!
alert( 9999999999999999 ); // shows 10000000000000000
```

Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.

Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. Как говорится: «как смог, так записал».
````

```smart header="Two zeroes"
Другим забавным следствием внутреннего представления чисел является наличие двух нулей: `0` и `-0`.

Все потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, включая нуль.

В большинстве случаев это поведение незаметно, так как операторы в JavaScript воспринимают их одинаковыми.
```



## Проверка: isFinite и isNaN

Помните эти специальные числовые значения?

- `Infinity` (и `-Infinity`) особенное численное значение, которое ведет себя в точности как математическая бесконечность ∞.
- `NaN` представляет ошибку.

Эти числовые значения принадлежат типу `number`, но они не являются "нормальными" числами, поэтому есть функции для их проверки:


- `isNaN(value)` конвертирует значение в числовое и проверят является ли оно `NaN`:

    ```js run
    alert( isNaN(NaN) ); // true
    alert( isNaN("str") ); // true
    ```

    Нужна ли нам эта функция? Разве не можем ли мы просто сравнить `=== NaN`? К сожалению, нет. Значение `NaN` уникально тем, что оно не является равным ни чему другому, даже самому себе:

    ```js run
    alert( NaN === NaN ); // false
    ```

- `isFinite(value)` конвертирует аргумент в число и возвращает `true`, если это не бесконечность, и не `NaN/Infinity/-Infinity`:

    ```js run
    alert( isFinite("15") ); // true
    alert( isFinite("str") ); // false, потому что специальтное значение: NaN
    alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
    ```

Иногда, `isFinite` используется для проверки, содержится ли в строке число:


```js run
let num = +prompt("Enter a number", '');

// вернер true, если аргумент является не числом, Infinity или -Infinity
alert( isFinite(num) );
```

Помните, что пустая строка интерпретируется как `0` во всех числовых функциях, включая`isFinite`.  

```smart header="Сравнить с `Object.is`"

Специально созданный метод [Object.is](mdn:js/Object/is), который сравнивает значения, подобно оператору `===`, лучше всего использовать в двух крайних случаях:

1. Работает с `NaN`: `Object.is(NaN, NaN) === true`, это хорошая вещь.
2. Значения `0` и `-0` разные: `Object.is(0, -0) === false`, редко имеет особое значение, но все таки, технически, эти значения разные.

Во всех других случаях `Object.is(a, b)` идентичен `a === b`.

Этот способ сравнения часто используется в JavaScript. Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, он использует `Object.is` (Определение [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)).
```


## parseInt и parseFloat

`+` и `Number() является строгим числовым преобразованием. Если значением является неправильное число, то интерпретатор выведет ошибку:

```js run
alert( +"100px" ); // NaN
```

Единственное исключение — это пробелы в начале строки и в конце, так как они игнорируются.

В реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения, например `"100px"` или `"12pt"` в CSS. Также, во множестве стран символ валюты записывается после номинала `"19€"`. Так как нам получить числовое значение из таких строк?

Для этого есть `parseInt` и `parseFloat`.

Они "читают" число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция `parseInt` возвращает целое число, когда `parseFloat` возвращает число с плавающей точкой:

```js run
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернется только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдет остановка чтения на второй точке
```

Функции `parseInt/parseFloat` вернут `NaN`, если они не смогли прочитать на одну цифру:

```js run
alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
```

````smart header="Второй аргумент `parseInt(str, radix)`"
Функция `parseInt()` имеет необязательный второй параметр. Он определяет систему счисления, таким образом `parseInt` может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

```js run
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456
```
````

## Другие математические функции

JavaScript has a built-in [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object which contains a small library of mathematical functions and constants.

A few examples:

`Math.random()`
: Returns a random number from 0 to 1 (not including 1)

    ```js run
    alert( Math.random() ); // 0.1234567894322
    alert( Math.random() ); // 0.5435252343232
    alert( Math.random() ); // ... (any random numbers)
    ```

`Math.max(a, b, c...)` / `Math.min(a, b, c...)`
: Returns the greatest/smallest from the arbitrary number of arguments.

    ```js run
    alert( Math.max(3, 5, -10, 0, 1) ); // 5
    alert( Math.min(1, 2) ); // 1
    ```

`Math.pow(n, power)`
: Returns `n` raised the given power

    ```js run
    alert( Math.pow(2, 10) ); // 2 in power 10 = 1024
    ```

There are more functions and constants in `Math` object, including trigonometry, which you can find in the [docs for the Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object.

## Summary

To write big numbers:

- Append `"e"` with the zeroes count to the number. Like: `123e6` is `123` with 6 zeroes.
- A negative number after `"e"` causes the number to be divided by 1 with given zeroes. That's for one-millionth or such.

For different numeral systems:

- Can write numbers directly in hex (`0x`), octal (`0o`) and binary (`0b`) systems
- `parseInt(str, base)` parses an integer from any numeral system with base: `2 ≤ base ≤ 36`.
- `num.toString(base)` converts a number to a string in the numeral system with the given `base`.

For converting values like `12pt` and `100px` to a number:

- Use `parseInt/parseFloat` for the "soft" conversion, which reads a number from a string and then returns the value they could read before the error.

For fractions:

- Round using `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round` or `num.toFixed(precision)`.
- Make sure to remember there's a loss of precision when working with fractions.

More mathematical functions:

- See the [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object when you need them. The library is very small, but can cover basic needs.
