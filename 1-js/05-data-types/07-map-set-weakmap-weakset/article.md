
# Map, Set, WeakMap и WeakSet

Сейчас мы знаем о следующих сложных структурах данных:

- Объекты для хранения именованных коллекций.
- Массивы для хранения упорядоченных коллекций.

Но этого не всегда достаточно для решения повседневных задач. Именно для этих случаев были придуманы `Map` и `Set`.

## Map

[Map](mdn:js/Map) -- это коллекция именованных элементов, как и `Object`. Но основное отличие в том, что `Map` позволяет использовать ключи любого типа.

Основные методы объекта:

- `new Map()` -- создаёт объект (коллекцию) Map.
- `map.set(key, value)` -- устанавливает элементу с  ключём `key` значение `value`.
- `map.get(key)` -- возвращает значение по ключу или `undefined`, если ключ`key` не присутствует в объекте `Map`.
- `map.has(key)` -- возвращает `true`, если `key` присутствует в Map или `false` в обратном случае.
- `map.delete(key)` -- удаляет элемент по ключу `key`.
- `map.clear()` -- очищает объект `Map` от всех элементов
- `map.size` -- возвращает текущее количество элементов.

Например:

```js run
let map = new Map();

map.set('1', 'str1');    //строка в качестве ключа
map.set(1, 'num1');      //цифра как ключ
map.set(true, 'bool1');  //булево значение как ключ

// помните обычный объект `Object`? Он приводит ключи к строкам
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // 'num1'
alert(map.get('1')); // 'str1'

alert(map.size); // 3
```

Как мы видим, в отличие от объектов ключи не были приведены к строкам. Возможно применение объектов любого типа в качестве ключей.

**Map может использовать объекты в качестве ключей.**

Например:
```js run
let john = { name: 'John' };

// давайте сохраним количество посещений для каждого пользователя
let visitsCountMap = new Map();

// объект john -- это ключ для значения в объекте Map
visitsCountMap.set(john, 123);

alert(visitsCountMap.get(john)); // 123
```

Использование объектов в качестве ключей -- это одна из известных и часто применяемых возможностей объекта `Map`. Для использования строковых ключей объекта `Object` может быть достаточно, но будет достаточно сложно найти способ заменить объект `Map` обычным объектом `Object` в примере выше.

Например:

```js run
let john = { name: "John" };

let visitsCountObj = {}; // попробуем использовать объект

visitsCountObj[john] = 123; // пробуем использовать объект john как ключ

*!*
// Вот как это было записано!
alert( visitsCountObj["[object Object]"] ); // 123
*/!*
```

Так как `john` -- это объект, он был преобразован в строку `"[object Object]"`. Все объекты без специальной обработки подобных преобразований приводятся к подобной строке, так что будьте внимательны, чтобы случайно всё не испортить.

Давным-давно, до появления `Map`, люди добавляли уникальные идентификаторы примерно таким образом:

```js run
// мы добавляем поле id
let john = { name: "John", *!*id: 1*/!* };

let visitsCounts = {};

// теперь мы сохраняем значение по полю id
visitsCounts[john.id] = 123;

alert( visitsCounts[john.id] ); // 123
```

...Но способ с объектом `Map` элегантнее.


```smart header="Как объект `Map` сравнивает ключи"
Чтобы проверить значения на равенство, объект `Map` использует алгоритм [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero). Это почти такое же сравнение что и `===`, с той лишь разницей что `NaN` считается равным `NaN`. Так что `NaN` так же может использоваться в качестве ключа.

Этот алгоритм не может быть заменён или модифицирован.
```


````smart header="Цепочка вызовов"

Каждый вызов `map.set` возвращает объект map, так что мы можем объединить вызовы в цепочку:

```js
map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
```
````

## Создание Map из Объекта

Для создания объекта `Map` мы можем использовать массив (или другой итерируемый объект) с парами ключ-значение как в следующем примере:

```js
// массив пар [ключ, значение]
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);
```

Существует встроенный метод [Object.entries(obj)](mdn:js/Object/entries), который возвращает массив пар ключ-значение из содержимого переданного объекта как раз в нужном формате.

Так что мы можем создать объект Map из объекта следующим образом:

```js
let map = new Map(Object.entries({
  name: "John",
  age: 30
}));
```

Здесь, `Object.entries` возвращает массив пар ключ-значение: `[ ["name","John"], ["age", 30] ]`. Это именно то что нужно для создания `Map`.

## Итерирование (перебор) объекта Map

Для перебора объекта `map` есть 3 метода:

- `map.keys()` -- возвращает итерируемый объект по ключам,
- `map.values()` -- возвращает итерируемый объект по значениям,
- `map.entries()` -- возвращает итерируемый объект элементов в формате `[ключ, значение]`, этот вариант используется по умолчанию в переборе с помощью `for..of`.

Например:

```js run
let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// перебор по ключам (vegetables)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// перебор по значениям (amounts)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // то же самое что и recipeMap.entries()
  alert(entry); // cucumber,500 (и так далее)
}
```

```smart header="Использование порядка добавления элементов"
В отличие от традиционных объектов  `Object`, в `Map` перебор происходит в том же самом порядке в каком происходило добавление элементов.
```

Кроме этого, объект `Map` имеет встроенный метод `forEach`, схожий со встроенным методом объекта`Array`:

```js
// выполняем функцию для каждой пары (ключ - key, значение - value)
recipeMap.forEach((value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 и так далее
});
```


## Set

Объект `Set` это коллекция значений, где каждое значение может появляться только один раз.

Его основные методы это:

- `new Set(iterable)` -- создает объект Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый объект Set.
- `set.add(value)` -- добавляет значение, возвращается тот же объект set.
- `set.delete(value)` -- удаляет значение, возвращает `true` если `значение` было в объекте Set в момент вызова, иначе `false`.
- `set.has(value)` -- возвращает `true`, если значение присутствует в объекте Set, иначе `false`.
- `set.clear()` -- удаляет все имеющиеся значения.
- `set.size` -- возвращает количество элементов в объекте Set.

Например, у нас ожидается множество гостей и нам необходимо составить их список. Но если мы будем считать всех подряд, мы можем ошибиться и посчитать кого-либо из гостей дважды, а гость должен появиться в списке только один раз.

Объект `Set` как раз то что нужно в этой ситуации:

```js run
let set = new Set();

let john = { name: 'John' };
let pete = { name: 'Pete' };
let mary = { name: 'Mary' };

// считаем гостей, некоторых из них несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
  alert(user.name); // John (потом Pete и Mary)
}
```

Альтернативой объекту `Set` может выступать массив для хранения гостей и дополнительный код, для проверки уже имеющегося элемента с помощью [arr.find](mdn:js/Array/find). Но в этом случае будет хуже производительность, потому что этот метод проходит весь массив при каждом вызове. `Set` имеет внутренние оптимизации для решения этой проблемы.

## Перебор объекта Set

Мы можем перебрать содержимое объекта set как с помощью метода `for..of` так и используя `forEach`:

```js run
let set = new Set(['oranges', 'apples', 'bananas']);

for (let value of set) alert(value);

// то же самое в случае forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```

Заметьте забавную вещь. Функция `forEach` в объекте `Set` имеет 3 аргумента: значение, потом _снова значение_, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

Это сделано для совместимости с объектом `Map` в котором `forEach` принимает 3 аргумента. Действительно выглядит немного странно, но в некоторых случаях может помочь легко заменить `Map` на `Set` и наоборот.

Set имеет те же встроенные методы что и объект `Map` :

- `set.keys()` -- возвращает итерируемый объект значений,
- `set.values()` -- то же самое что и `set.keys`, присутствует для обратной совместимости с `Map`,
- `set.entries()` -- возвращает итерируемый объект вида `[значение, значение]`, присутствует для обратной совместимости с `Map`.

## WeakMap и WeakSet

`WeakSet` специальный подвид объекта `Set`, который не мешает внутренним механизмам JavaScript удалить его элементы из памяти. `WeakMap` то же самое для объекта `Map`.

Как мы знаем из главы <info:garbage-collection>, движок JavaScript хранит значения в памяти до тех пор пока на них есть ссылки (и эти значения могут быть использованы).

Например:
```js
let john = { name: "John" };

// объект доступен, переменная john это ссылка на него

// перепишем ссылку
john = null;

*!*
// объект будет удален из памяти
*/!*
```

Обычно свойство объекта, элемента массива или другой структуры данных считаются достижимыми и сохраняются в памяти до тех пор, пока структура данных содержится в памяти.

Например, если мы поместим объект в массив, то до тех пор пока массив существует, объект также будет существовать в памяти, несмотря на то что других ссылок на него нет.

Например:

```js
let john = { name: "John" };

let array = [ john ];

john = null; // перезаписываем ссылку на объект

*!*
// объект john хранится в массиве, поэтому он не будет удален сборщиком мусора
// мы можем взять его значение как array[0]
*/!*
```

Если мы используем объект как ключ в обычном `Map`, то до тех пор пока существует `Map`, также будет существовать и наш объек. Он занимает место в памяти и не может быть удален сборщиком мусора.

Например:

```js
let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // перезаписываем ссылку на объект

*!*
// объект john сохранен внутри объекта `Map`,
// он доступен с помощью map.keys()
*/!*
```

`WeakMap/WeakSet` принципиально другие в этом аспекте. Они не предотвращают удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.

Давайте посмотрим что это означает на примере `WeakMap`.

Первое его отличие от `Map` в том, что ключи в `WeakMap` должны быть объектами, а не примитивными значениями:

```js run
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

*!*
// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект
*/!*
```

Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удален из памяти (и из объекта `WeakMap`) автоматически.

```js
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // перезаписываем ссылку на объект

// объект john удален из памяти!
```

Сравните это поведение с поведением обычного `Map`, пример которого был приведен раньше. Теперь `john` существует только как ключ в `WeakMap` и может быть удален оттуда автоматически.

`WeakMap` не поддерживает перебор и методы `keys()`, `values()`, `entries()`, так что нет способа взять все ключи или значение из него.

В `WeakMap` присутствуют только следующие методы:

- `weakMap.get(key)`
- `weakMap.set(key, value)`
- `weakMap.delete(key)`
- `weakMap.has(key)`

К чему такие ограничения? Из-за особенностей технической реализации. Если объект потеряет все ссылки (как объект `john` в примере выше), то он будет автоматически удален сборщиком мусора. Но нет специального указания *в какой момент произойдет эта очистка*.

Решение о том в какой момент произойдет очистка принимает движок JavaScript. Он может посчитать необходимым удалить объект прямо сейчас, так и отложить удаление, чтобы удалить большее количество объектов за раз. Так что, технически, количество элементов в объекте `WeakMap` не известно. Движок может удалить его сразу или потом, или сделать это частично. По этой причине методы, которые имеют доступ к коллекции `WeakMap` целиком не поддерживаются.

Но откуда же нам взять эти методы?

Основная идея `WeakMap` в том чтобы мы могли хранить что-то с объектом в качестве ключа до тех пор пока существует этот объект. Но мы не храним объект в памяти только потому, что где-то хранится связанное с ним значение.

```js
weakMap.set(john, 'секретные материалы');
// если исчезнет john, то и секретные материалы тоже исчезнут
```

Это поведение полезно, когда нам у нас есть главное хранилище для объектов и нам нужно дополнительное место в котором необходимо хранить вспомогательную информацию связанную с этими объектами, но только до тех пор пока объект существует.

Давайте рассмотрим случай из жизни.

Например, у нас есть код который хранит количество посещений каждого пользователя. Данные хранятся в объекте map: пользователь это ключ, а количество посещений - значение. Когда пользователь уходит, нам нет необходимости хранить количество посещений.

Очевидный способ -- отслеживать поведение пользователей и как только они уходят вручную очищать объект `Map`

```js run
let john = { name: "John" };

// Map: пользователь => количество посещений
let visitsCountMap = new Map();

// объект john -- это ключ
visitsCountMap.set(john, 123);

// теперь, когда john покидает нас, то нам не нужна ссылка на это объект
john = null;

*!*
// но этот объект до сих пор хранится в коллекции и нам нужно удалить его оттуда!
*/!*
alert( visitsCountMap.size ); // 1
// он до сих пор хранится в памяти, потому что Map использует его в качестве ключа
```

Другой способ -- использовать `WeakMap`:

```js
let john = { name: "John" };

let visitsCountMap = new WeakMap();

visitsCountMap.set(john, 123);

// теперь, когда john покидает нас, то нам не нужна ссылка на это объект
john = null;

// теперь у нас нет других ссылок на john кроме как в WeakMap,
// так что объект будет автоматически удалён и из памяти и из коллекции visitsCountMap
```

С обычным `Map`, очистка памяти после того как пользователь ушёл может быть утомительной задачей: нам не только нужно удалить пользователя из главного хранилища (он может быть как в переменной так и в массиве), но также очистить и другие места хранения ссылки на этот объект, как например `visitsCountMap`. И это решение может стать более громоздким в более сложных случаях, когда поведение пользователей отслеживается в одном месте, а дополнительные структуры в другом, и у нас нет информации об удалении пользователя.

```summary
`WeakMap` может сделать вашу жизнь проще, потому как он очищается автоматически. Данные в нем, как пользователи в примере выше, хранятся автоматически до тех пор, пока существует объект используемый в качестве ключа.
```

Объект `WeakSet` ведет себя похоже:

- Он аналогичен объекту `Set`, мы можем добавлять в `WeakSet` только объекты (не примитивные значения).
- Объект присутствует в коллекции только до тех пор, пока этот объект доступен где-то еще.
- Как и `Set`, он поддерживает `add`, `has` и `delete`, но не `size`, `keys()` и не является итерируемым.

Например, мы можем отслеживать прочтено ли сообщение:

```js
let messages = [
    {text: "Hello", from: "John"},
    {text: "How goes?", from: "John"},
    {text: "See you soon", from: "Alice"}
];

// заполним коллекцию элементами массива (3 сообщения)
let unreadSet = new WeakSet(messages);

// используем unreadSet, чтобы узнать прочитано ли сообщение
alert(unreadSet.has(messages[1])); // true

// удалим его из коллекции после прочтения
unreadSet.delete(messages[1]); // true

// и когда мы удалим сообщение из массива сообщений, то и коллекция очистится автоматически
messages.shift();

*!*
// нам не нужно вручную очищать unreadSet, там сейчас только 2 элемента
*/!*
// (хотя технически мы не знаем, когда движок JS очистит его)
```

Наиболее заметным ограничением `WeakMap` и `WeakSet` отсутствие возможности перебора и методов, для того чтобы взять текущее содержимое коллекции. Это может казаться неудобным, но не мешает `WeakMap/WeakSet` выполнять своё основное предназначение -- быть "дополнительным" хранилищем информации для объектов, которые хранятся или управляются где-то в другом месте.

## Итого

Обычные коллекции:
- `Map` -- коллекция пар ключ-значение.

  Отличия от обычного объекта `Object`:

  - Что угодно может быть ключём, в том числе и объекты.
  - Перебор в порядке добавления элементов.
  - Дополнительные удобные свойства, такие как `size`.

- `Set` -- коллекция уникальных значений.

  - В отличие от массива не позволяет изменять порядок элементов.
  - Сохраняет порядок вставки.

Коллекции, которые не препятствуют сборке мусора:

- `WeakMap` -- вариант `Map` который позволяет использовать в качестве ключей лишь объекты и удаляет их, если эти объекты становятся недостижимыми.

  - Не поддерживает операции над коллекцией целиком: нет свойства `size`, `clear()` и нет возможности перебора.

- `WeakSet` -- вариант `Set` который хранит только объекты и удаляет их если объекты становятся недостижимыми.

  - Также не поддерживает `size/clear()` и перебор коллекции.

`WeakMap` и `WeakSet` используются в качестве "вторичных" структур данных в дополнение к "основным" объектам хранения. Если объект будет удален из главного хранилища, и если он присутствует только в `WeakMap/WeakSet`, то он будет автоматически удален.
