Подходящий вариант -- это использование `WeakSet`:

```js
let messages = [
    {text: "Hello", from: "John"},
    {text: "How goes?", from: "John"},
    {text: "See you soon", from: "Alice"}
];

let readMessages = new WeakSet();

// Два сообщения были прочитаны
readMessages.add(messages[0]);
readMessages.add(messages[1]);
// readMessages содержит 2 элемента

// ...давайте снова прочитаем первое сообщение!
readMessages.add(messages[0]);
// readMessages до сих пор содержит 2 элемента

// Вопрос: было ли сообщение message[0] прочитано?
alert("Read message 0: " + readMessages.has(messages[0])); // true

messages.shift();
// теперь readMessages содержит 1 элемент (хотя технически память может быть очищена позже)
```

`WeakSet` позволяет хранить набор сообщений, и легко проверять наличие сообщения в нем.

Он очищается автоматически. Компромисс в том, что мы не можем перебрать его. Мы не можем получить «все прочитанные сообщения» напрямую. Но мы можем сделать это, перебирая все сообщения и фильтруя те, которые находятся в коллекции `WeakSet`.

P.S. Добавление собственного свойства к каждому сообщению может быть опасным, если сообщения управляются чужим кодом, но мы можем сделать это с помощью символов, чтобы избежать конфликтов.

Например:
```js
// свойство и символом вместо имени, которое известно только нашему коду
let isRead = Symbol("isRead");
messages[0][isRead] = true;
```

Теперь, даже если чужой код использует цикл `for..in` для перебора свойств сообщения, наш секретный флаг не появится.
