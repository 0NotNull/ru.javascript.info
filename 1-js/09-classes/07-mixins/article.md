# Mixins

В JavaSctipt мы можем использовать наследование только от одного объекта. Объект имеет единственный `[[Prototype]]`. И класс может расширить только один другой класс.

Иногда это может огранчичивать нас. Например, у нас есть класс `StreetSweeper` и класс `Bicycle`, и хотим создать `StreetSweepingBicycle`.

Или, поговорим о программировании, у нас есть класс `Renderer`, который реализует шаблон и класс `EventEmitter`, который релизует событие, и нам надо объеденить их функционалы вместе с классом `Page`, создадим страницу которая будет использовать шаблон и использовать событие.

Для таких случаев существует "mixin'ы".

Как говориться в Викепедии [mixin](https://ru.wikipedia.org/wiki/Mixin) является классом, который имеет методы и мы можем их использовать в других классов, без необходимости быть родителем этих классов.

Другими словами mixin определяет методы, которые реализуют определенное поведение. Мы не используем его в одиночку, а используем его, чтобы добавить другим классам больше функционала.

## Mixin пример 

Простой путь создать mixin в JavaScript - это создать объект с использующимися методами, так что мы легко можем объединить их в прототип любого класса.

В примере ниже mixin `sayHiMixin` имеет методы для речи User'a:

```js run
*!*
// mixin
*/!*
let sayHiMixin = {
  sayHi() {
    alert(`Hello ${this.name}`);
  },
  sayBye() {
    alert(`Bye ${this.name}`);
  }
};

*!*
// использование:
*/!*
class User {
  constructor(name) {
    this.name = name;
  }
}

// копируем методы
Object.assign(User.prototype, sayHiMixin);

// сейчас User можем сказать hi
new User("Dude").sayHi(); // Hello Dude!
```
Это не наследование, a простой способ скопировать методы. Таким образом, класс 'User' может расширять другие классы и так же содержитать в себе методы от mixin'a, например:

```js
class User extends Person {
  // ...
}

Object.assign(User.prototype, sayHiMixin);
```

Mixin'ы могут использовать наследование между собой.

В примере ниже `sayHiMixin` наследуется от `sayMixin`:

```js run
let sayMixin = {
  say(phrase) {
    alert(phrase);
  }
};

let sayHiMixin = {
  __proto__: sayMixin, // (или мы можем использовать Object.create для определения прототипа)
                  
  sayHi() {
    *!*
    // вызываем метод родителя
    */!*
    super.say(`Hello ${this.name}`);
  },
  sayBye() {
    super.say(`Bye ${this.name}`);
  }
};

class User {
  constructor(name) {
    this.name = name;
  }
}

// копируем методы
Object.assign(User.prototype, sayHiMixin);

// сейчас User может сказать hi
new User("Dude").sayHi(); // Hello Dude!
```

Обратите внимание, что мы вызвали родительский метод `super.say()` из  'sayHiMixin' в прототипе другого mixin'a, а не в классе.

![](mixin-inheritance.png)

Это связано с тем, что  методы из `sayHiMixin` имеют установку `[[HomeObject]] `. А `super` на самом деле означает` sayHiMixin .__ proto__`, а не `User .__ proto__`.

## События mixin

сейчас давайте создадим mixin для реального случая.

Важная особенность при работе с объектами это работа с событиями. 

Т.е. объект должен иметь метод для «генерации события», когда с ним происходит что-то важное, а другие объекты должны иметь возможность «считывать» такие события.

Событие может иметь имя, необязательно, и связь между некоторыми дополнительными данными.

Например объект  `user` может генерировтаь события `"login"` когда посетитель входит. А другой объект `calendar` может захотеть получать его события, чтобы загрузить календарь для вошедшего человека.

Или `menu` может генерировать событие `"select"`, когда меню элемент выбран, или другие объекты могут захотеть получить эту информацию и отреагировать на это событие.

События - это способ «поделиться информацией» со всеми, кто этого захочет. Они могут быть полезны в любом классе, поэтому давайте сделаем для них mixin:

```js run
let eventMixin = {
  /**
   * Опишем события, используя:
   *  menu.on('select', function(item) { ... }
  */
  on(eventName, handler) {
    if (!this._eventHandlers) this._eventHandlers = {};
    if (!this._eventHandlers[eventName]) {
      this._eventHandlers[eventName] = [];
    }
    this._eventHandlers[eventName].push(handler);
  },

  /**
   * Закроем событие, используя:
   *  menu.off('select', handler)
   */
  off(eventName, handler) {
    let handlers = this._eventHandlers && this._eventHandlers[eventName];
    if (!handlers) return;
    for (let i = 0; i < handlers.length; i++) {
      if (handlers[i] === handler) {
        handlers.splice(i--, 1);
      }
    }
  },

  /**
   * Сгенерируем событие и прикрепим данные
   *  this.trigger('select', data1, data2);
   */
  trigger(eventName, ...args) {
    if (!this._eventHandlers || !this._eventHandlers[eventName]) {
      return; // no handlers for that event name
              // без обработчиков для этого события
    }

    // вызовем обработчиков
    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));
  }
};
```

И так у нас 3 метода:

1. `.on(eventName, handler)` -- назначили функцию `handler` чтобы запустить событие с этим именем. И храним обработчиков в `_eventHandlers` свойстве.

2. `.off(eventName, handler)` -- удаляем функцию из списка обработчиков

3. `.trigger(eventName, ...args)` -- генерируем событие: все назначенные обработчики вызываются и в `args` передаются в качестве аргументов.

Использование:

```js run
// Создадим класс
class Menu {
  choose(value) {
    this.trigger("select", value);
  }
}
// Добавим mixin
Object.assign(Menu.prototype, eventMixin);

let menu = new Menu();

// Вызовем выбранный обработчик:
*!*
menu.on("select", value => alert(`Value selected: ${value}`));
*/!*

// Запустили событие => покажет выбранное значение: 123
menu.choose("123"); // значение выбранно
                   
```

Сейчас у нас есть код, который реаигирует на выбор пользователя и мы можем связать его с `menu.on(...)`.

И `eventMixin` может добавить поведение в любой класс какой мы хотим, без вмешательства в цепочку наследования.

## Итого

*Mixin* -- общий термин в объектно-оренитированном программировании: класс, который содержит в себе методы для других классов.

В других языках, как Python резрешается создавать mixin'ы используя множественное наследование. JavaScript не поддерживает множественное наследование, но с помощью mixin мы можем реализовать это скопировав методы в протитоп. 

Мы можем использовать mixin'ы для дополнения множественного поведения классов, например, для обработки события, как мы делали это выше.

Мы так же можем использовать миксины, как способ дополнить любой класс множественными поведениемя, например, обработкой событий, как мы сделали выше.

С mixin'ами могут быть проблемы,если они будут перезаписывать нативные метода. Стоит помнить это и быть внимательней при назначении имени mixin, чтобы избежать такую возможность ошибки.
