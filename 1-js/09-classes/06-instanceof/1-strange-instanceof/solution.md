Да, действительно выглядит странно.

Но `instanceof` не учитывает саму функцию, напротив -- только `prototype`, который оператор проверяет на совпадения в прототипной цепочке.

И в данном примере `a.__proto__ == B.prototype`, так что `instanceof` возвращает `true`.

Таким образом, по логике `instanceof`, `prototype` в действительности определяет тип, а не функция-конструктор.
