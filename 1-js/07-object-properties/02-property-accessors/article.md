
# Свойства - геттеры и сеттеры

Есть два типа свойств объекта.

Первый тип это *свойства-данные (data properties)*. Мы уже знаем, как работать с ними. На самом деле, все свойства, которые мы использовали до текущего момента были свойствами-данными.

Второй тип свойств мы ещё не рассматривали. Это *свойства-аксессоры (accessor properties)*. По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.

## Геттеры и сеттеры

Свойства-аксессоры представлены как "геттер" и "сеттер" методы. В литерале объекта они представлены методами `get` и `set`:

```js
let obj = {
  *!*get propName()*/!* {
    // геттер, код получения obj.propName
  },

  *!*set propName(value)*/!* {
    // сеттер, код присвоения obj.propName = value
  }
};
```

Геттер срабатывает, когда `obj.propName` читается, сеттер -- когда значение назначается.

Для примера, у нас есть объект `user` со свойствами `name` и `surname`:

```js run
let user = {
  name: "John",
  surname: "Smith"
};
```

Сейчас мы хотим добавить свойство объекта "fullName", которое должно стать "John Smith". Само собой, мы не хотим дублировать уже имеющуюся информацию. Мы можем реализовать это с использованием свойства-аксессора.

```js run
let user = {
  name: "John",
  surname: "Smith",

*!*
  get fullName() {
    return `${this.name} ${this.surname}`;
  }
*/!*
};

*!*
alert(user.fullName); // John Smith
*/!*
```

Снаружи свойство-аксессора выглядит как обычное свойство. В этом и заключается идея свойств-аксессора. Мы не хотим *вызывать* `user.fullName` как функцию, мы *читаем* как обычное свойство: геттер выполнит всю работу за кулисами.

На данный момент `fullName` имеет только геттер. Если попытаться присвоить значение свойству `user.fullName`, то это вызовет ошибку.

Давайте исправим это, добавив сеттер для `user.fullName`:

```js run
let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },

*!*
  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
*/!*
};

// присвоим fullName значение.
user.fullName = "Alice Cooper";

alert(user.name); // Alice
alert(user.surname); // Cooper
```

Сейчас мы имеем "виртуальное" свойство. Его можно прочитать и изменить, но по факту его не существует.

```smart header="Accessor properties are only accessible with get/set"
Как только свойство определено с помощью `get prop()` или `set prop()`, оно становится свойством-аксессором, а не свойством-данным.

- Если определен геттер -- мы можем прочитать свойство `object.prop`, иначе нет.
- Если определен сеттер -- мы можем установить свойство `object.prop=...`, иначе нет.

И в любом другом случае мы не можем удалить свойство-аксессор.
```


## Дескрипторы свойств доступа

Дескрипторы свойств-аксессора отличаются по сравнению со свойствами-данными.

Свойства-аксессоры не имеют `value` и `writable`, но взамен предлагают `get` и `set` функции.

Таким образом, дескриптор доступа может иметь:

- **`get`** -- функция без аргументов, которая сработает при чтении свойства,
- **`set`** -- функция, принимающая один аргумент, вызываемая при присвоении свойства,
- **`enumerable`** -- то же самое, что и для свойств-данных,
- **`configurable`** -- то же самое, что и для свойств-данных.

Например, чтобы создать метод доступа `fullName` с `defineProperty`, мы можем передать дескриптор с использованием `get` и `set`:

```js run
let user = {
  name: "John",
  surname: "Smith"
};

*!*
Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
*/!*
});

alert(user.fullName); // John Smith

for(let key in user) alert(key); // name, surname
```

Обратите внимание, что свойство объекта может быть только свойством-аксессора или свойством-данных.

Если вы попытаетесь подставить `get` и `value` в одном дескрипторе, это вызовет ошибку:

```js run
*!*
// Ошибка: Неправильное свойство дескриптора.
*/!*
Object.defineProperty({}, 'prop', {
  get() {
    return 1
  },

  value: 2
});
```

## Умные геттеры/сеттеры

Геттеры/сеттеры можно использовать как обёртки над "реальными" значениями свойств, чтобы получить больше контроля над ними.

Например, если мы хотим запретить устанавливать короткое имя для `user`, мы можем хранить `name` в специальном свойстве `_name`, отфильтровав значение в сеттере:

```js run
let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length < 4) {
      alert("Короткое имя, должно быть более 4 символов");
      return;
    }
    this._name = value;
  }
};

user.name = "Pete";
alert(user.name); // Pete

user.name = ""; // Короткое имя...
```

Технически, внешний код все еще может получить доступ к имени напрямую с помощью `user._name`, но существует широко известное соглашение о том, что свойства, которые начинаются с символа `"_"`, являются внутренними, и к ним не следует обращаться из-за пределов объекта.


## Использование для совместимости

Одна из хороших идей, стоящих за геттерами и сеттерами -- они позволяют взять под контроль "обычные" свойства-данных и корректировать их в любой момент.

Например, ранее мы начали реализовывать объект `user`, используя свойства-данные `name` и `age`:

```js
function User(name, age) {
  this.name = name;
  this.age = age;
}

let john = new User("John", 25);

alert( john.age ); // 25
```

...Но рано или поздно всё может измениться. Взамен `age` мы можем решить хранить `birthday`, потому что так более точно и удобно:

```js
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;
}

let john = new User("John", new Date(1992, 6, 1));
```

Что нам делать со старым кодом, который использует свойство `age`?

Мы можем попытаться найти все такие места и изменить их, но это отнимает время и может быть тяжело выполнимо, если код был написан другими людьми. И кроме того, `age` -- это отличное свойство для `user`, верно? В некоторых ситуациях это то, что нам нужно.

Добавление геттера для `age` смягчит эту проблему:

```js run no-beautify
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

*!*
  // возраст рассчитывается из текущей даты и дня рождения
  Object.defineProperty(this, "age", {
    get() {
      let todayYear = new Date().getFullYear();
      return todayYear - this.birthday.getFullYear();
    }
  });
*/!*
}

let john = new User("John", new Date(1992, 6, 1));

alert( john.birthday ); // birthday is available
alert( john.age );      // ...а также возраст
```

Теперь старый код тоже работает, и у нас есть отличное дополнительное свойство.
