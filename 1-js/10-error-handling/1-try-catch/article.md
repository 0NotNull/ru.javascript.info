# Обработка ошибок, "try..catch"

Неважно насколько мы хороши в программировании, иногда наши скрипты содержат ошибки. Они могут возникать из-за наших промахов, неожиданного ввода пользователя, неправильного ответа сервера и по тысяче других причин.

Обычно, скрипт "падает" (сразу же останавливается) в случае ошибки, с выводом ошибки в консоль.

Но есть синтаксическая конструкция `try..catch`, которая позволяет "перехватывать" ошибки, и вместо падения, сделать что-то более осмысленное.

## Синтаксис "try..catch"

Конструкция `try..catch` состоит из двух основных блоков: `try`, и затем `catch`:

```js
try {

  // код...

} catch (err) {

  // обработка ошибки

}
```

Работает она так:

1. Сначала выполняется код внутри блока `try {...}`.
2. Если в нём нет ошибок, то блок `catch(err)` игнорируется: выполнение доходит до конца `try` и потом прыгает через `catch`.
3. Если в нем возникает ошибка, то выполнение `try` прерывается, и поток управления переходит в начало `catch(err)`. Переменная `err` (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.

![](try-catch-flow.png)

Таким образом, при ошибке в блоке `try {…}` скрипт не "падает", и мы получаем возможность обработать ошибку внутри `catch`.

Давайте рассмотрим больше примеров.

- Пример без ошибок: выведет  `alert` `(1)` и `(2)`:

    ```js run
    try {

      alert('Начало блока try');  // *!*(1) <--*/!*

      // ...код без ошибок

      alert('Конец блока try');   // *!*(2) <--*/!*

    } catch(err) {

      alert('catch игнорируется, так как нет ошибок'); // (3)

    }

    alert("...Потом код продолжит выполнение");
    ```
- Пример с ошибками: выведет `(1)` и `(3)`:

    ```js run
    try {

      alert('Начало блока try');  // *!*(1) <--*/!*

    *!*
      lalala; // ошибка, переменная не определена!
    */!*

      alert('Конец блока try (никогда не выполнится)');  // (2)

    } catch(err) {

      alert(`Возникла ошибка!`); // *!*(3) <--*/!*

    }

    alert("...Потом код продолжит выполнение");
    ```


````warn header="`try..catch` работает только для ошибок, возникающих во время исполнения кода"
Чтобы `try..catch` работал, код должен быть выполнимым. Другими словами, это должен быть корректный JavaScript код.

Он не сработает, если код синтаксически неверен, например, содержит несовпадающее количество фигурных скобок:

```js run
try {
  {{{{{{{{{{{{
} catch(e) {
  alert("Движок не может понять этот код, он не корректен");
}
```

JavaScript движок сначала читает код, а затем исполняет его. Ошибки, которые возникают во время фазы чтения, называются ошибками парсинга. Их нельзя обработать (изнутри этого кода), потому что движок не понимает код.

Таким образом, `try..catch` может обрабатывать ошибки, которые возникают в корректном коде. Такие ошибки называют "ошибками во время выполнения", а иногда "исключениями".
````


````warn header="`try..catch` работает синхронно"
Ошибку, которая произойдёт в коде, запланированном "на будущее", например в `setTimeout`, `try..catch` не поймает:

```js run
try {
  setTimeout(function() {
    noSuchVariable; // скрипт упадет тут
  }, 1000);
} catch (e) {
  alert( "не сработает" );
}
```

Это потому что `try..catch` на самом деле оборачивает вызов `setTimeout`, которые планирует выполнение функции. Но сама функция выполняется позже, когда движок уже покинул конструкцию `try..catch`.

Чтобы поймать исключение внутри запланированной функции, `try..catch` должен находиться внутри самой этой функции:
```js run
setTimeout(function() {
  try {    
    noSuchVariable; // try..catch обрабатывает ошибку!
  } catch {
    alert( "ошибка поймана тут!" );
  }
}, 1000);
```
````

## Объект ошибки

Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем объект передается как аргумент в блок `catch`:

```js
try {
  // ...
} catch(err) { // <-- объект ошибки, можно использовать другое название вместо err
  // ...
}
```

Для всех встроенных ошибок, объект ошибки внутри `catch` имеет два основных свойства:

`name`
: Имя ошибки. Для неопределенных переменных это `"ReferenceError"`.

`message`
: Текстовое сообщение о деталях ошибки.

Имеются также другие нестандартные свойства доступные в большинстве окружений. Одно из самых широко используемых и поддерживаемых это:

`stack`
: Текущий стек вызова: строка содержащая информацияю о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки.

Например:

```js run untrusted
try {
*!*
  lalala; // ошибка, перерменная не определена!
*/!*
} catch(err) {
  alert(err.name); // ReferenceError
  alert(err.message); // lalala не определена
  alert(err.stack); // ReferenceError: lalala не определена в ...

  // Может также вывести ошибку как целое
  // Ошибка приводится к строке как "name: message"
  alert(err); // ReferenceError: lalala не определена
}
```

## Необязательное связывание "catch"

[recent browser=new]

Если вам не нужны детали ошибки, `catch` можно пропустить:

```js
try {
  // ...
} catch {
  // объект ошибки пропущен
}
```

## Использование "try..catch"

Давайте рассмотрим реальные случаи использования `try..catch`.

Как мы уже знаем, JavaScript поддерживает метод [JSON.parse(str)](mdn:js/JSON/parse) для чтения закодированных JSON значений.

Обычно он используется для декодирования данных полученных по сети, от сервера или из другого источника.

Мы получаем их и вызываем `JSON.parse`, вот так:

```js run
let json = '{"name":"John", "age": 30}'; // данные с сервера

*!*
let user = JSON.parse(json); // преобразовали текстовое представление в JS объект
*/!*

// теперь user -- это объект со свойствами из строки
alert( user.name ); // John
alert( user.age );  // 30
```

Вы можете найти более детальную информацию о JSON в главе <info:json>.

**Если `json` некорректен, `JSON.parse` генерирует ошибку, то есть скрипт "падает".**

Устроит ли нас такое поведение? Конечно нет!

Получается, что если вдруг что-то не так с данными, то посетитель никогда (если, конечно, не откроет консоль) об этом не узнает. А люди очень не любят, когда что-то "просто падает", без всякого сообщения об ошибке.

Давайте используем `try..catch` для обработки ошибки:

```js run
let json = "{ bad json }";

try {

*!*
  let user = JSON.parse(json); // <-- тут возникает ошибка...
*/!*
  alert( user.name ); // не сработает

} catch (e) {
*!*
  // ...выполнения прыгает сюда
  alert( "Извините, в данных ошибка, мы попробуем получить их ещё раз." );
  alert( e.name );
  alert( e.message );
*/!*
}
```

Здесь мы используем блок `catch` только для вывода сообщения, но мы также можем сделать гораздо больше: отправить новый сетевой запрос, предложить посетителю альтернативный способ, отослать информацию об ошибке на сервер для логгирования, ... Намного лучше, чем просто "падение".

## Генерация своих ошибок

Что если `json` синтаксически корректен, но не содержит необходимого свойства `name`?

Например так:

```js run
let json = '{ "age": 30 }'; // данные неполны

try {

  let user = JSON.parse(json); // <-- выполнится без ошибок
*!*
  alert( user.name ); // нет свойства name!
*/!*

} catch (e) {
  alert( "не выполнится" );
}
```

Здесь `JSON.parse` выполнится без ошибок, но на самом деле отсутствие свойства `name` для нас ошибка.

Для того, чтобы унифицировать обработку ошибок, мы воспользуемся оператором `throw`.

### Оператор "throw"

Оператор "throw" генерирует ошибку.

Синтаксис:

```js
throw <error object>
```

Технически в качестве объекта ошибки можно передать что угодно. Это может быть даже примитив, число или строка, но всё же лучше, чтобы это был объект, желательно со свойствами `name` и `message` (для совместимости со встроенными ошибками).

В JavaScript есть множество встроенных конструкторов для стандартных ошибок: `Error`, `SyntaxError`, `ReferenceError`, `TypeError` и другие. Можно использовать и их для создания объектов ошибки.  

Их синтаксис:

```js
let error = new Error(message);
// или
let error = new SyntaxError(message);
let error = new ReferenceError(message);
// ...
```

Для встроенных ошибок (не для любых объектов, только для ошибок), свойство `name` -- это в точности имя конструктора. И свойство `message` берется из аргумента.  

Например:

```js run
let error = new Error("Такое произошло o_O");

alert(error.name); // Error
alert(error.message); // Такое произошло o_O
```

Давайте посмотрим какую ошибку генерирует `JSON.parse`:

```js run
try {
  JSON.parse("{ bad json o_O }");
} catch(e) {
*!*
  alert(e.name); // SyntaxError
*/!*
  alert(e.message); // Unexpected token o in JSON at position 0
}
```

Как мы видим, это `SyntaxError`.

И в нашем случае отсутствие свойства `name` может рассматриваться как синтаксическая ошибка, предполагая что пользователи должны иметь имена.

Давайте пробросим ее:

```js run
let json = '{ "age": 30 }'; // данные неполны

try {

  let user = JSON.parse(json); // <-- выполнится без ошибок

  if (!user.name) {
*!*
    throw new SyntaxError("Данные неполны: нет имени"); // (*)
*/!*
  }

  alert( user.name );

} catch(e) {
  alert( "JSON Error: " + e.message ); // JSON Error: Данные неполны: нет имени
}
```

В строке `(*)` оператор `throw` генерирует `SyntaxError` с указанным `message`. Таким же образом JavaScript генерирует ошибку сам. Выполнение блока `try` немедленно останавливается и поток управления прыгает в `catch`.

Теперь блок `catch` становится единственным место для обработки всех ошибок: и для `JSON.parse`, и для других случаев.

## Проброс исключения

В примере выше мы использовали `try..catch` для обработки некорректных данных. Но возможно ли, что *другая неожиданная ошибка* может возникнуть внутри блока `try {...}`? Такая как неопределенная переменная или какая-то еще, а не только ошибка связанная с некорректными данными.

Пример:

```js run
let json = '{ "age": 30 }'; // данные неполны

try {
  user = JSON.parse(json); // <-- забыл добавить "let" перед user

  // ...
} catch(err) {
  alert("JSON Error: " + err); // JSON Error: ReferenceError: user is not defined
  // (не JSON ошибка на самом деле)
}
```
 
Конечно, возможно все! Программисты совершают ошибки. Даже в утилитах с открытым исходным кодом, используемых миллионами людей на протяжении десятилетий -- вдруг может быть обнаружена ошибка, которая приводит к ужасным взломам (как это случилось с инструментом `ssh`).

В нашем случае `try..catch` предназначен для выявления ошибок связанным с некорректными данными. Но по своей природе, `catch` получает *все* свои ошибки из `try`. Здесь он получает неожиданную ошибку, но все также показывает то же самое сообщение `"JSON Error"`. Это неправильно и также затрудняет отладку кода.

К счастью, мы можем выяснить, какую ошибку мы получим, например, по ее свойству `name`:

```js run
try {
  user = { /*...*/ };
} catch(e) {
*!*
  alert(e.name); // "ReferenceError" из-за неопределенной переменной
*/!*
}
```

Правило простое:

**`catch` должен обрабатывать только те ошибки, которые ему известны, и "пробрасывать" все остальные.**

Техника "проброс исключения" может быть объяснена более детально как:

1. Блок `catch` получает все ошибки.
2. В блоке `catch(err) {...}` мы анализируем объект ошибки `err`.
3. Если мы не знаем как её обработать, тогда делаем `throw err`.

В коде ниже, мы используем проброс исключением таким образом, что `catch` обрабатывает только `SyntaxError`:

```js run
let json = '{ "age": 30 }'; // данные неполны
try {

  let user = JSON.parse(json);

  if (!user.name) {
    throw new SyntaxError("Данные неполны: нет имени");
  }

*!*
  blabla(); // неожиданная ошибка
*/!*

  alert( user.name );

} catch(e) {

*!*
  if (e.name == "SyntaxError") {
    alert( "JSON Error: " + e.message );
  } else {
    throw e; // rethrow (*)
  }
*/!*

}
```

Ошибка в строке `(*)` из блока `catch` "выпадает наружу" и может быть поймана другой внешней конструкцией `try..catch` (если есть), или "повалит скрипт".

Таким образом блок `catch` фактически обрабатывает только те ошибки, с которыми он знает, как справляться, и пропускает остальные.

Пример ниже демонстрирует как такие ошибки могут быть пойманы с помощью еще одного уровня `try..catch`:

```js run
function readData() {
  let json = '{ "age": 30 }';

  try {
    // ...
*!*
    blabla(); // ошибка!
*/!*
  } catch (e) {
    // ...
    if (e.name != 'SyntaxError') {
*!*
      throw e; // проброс исключения (не знаю как это обработать)
*/!*
    }
  }
}

try {
  readData();
} catch (e) {
*!*
  alert( "Внешний catch поймал: " + e ); // поймал!
*/!*
}
```

Здесь `readData` знает только как обработать `SyntaxError`, тогда как внеший `try..catch` знает, как обработать все.

## try..catch..finally

Подождите, это еще не все.

Конструкция `try..catch` может содержать еще одну секцию: `finally`.

Если секция есть, то она выполняется в любом случае:

- после `try`, если не было ошибок,
- после `catch`, если ошибки были.

Расширенный синтаксис выглядит следующим образом:

```js
*!*try*/!* {
   ... пробуем выполнить код...
} *!*catch*/!*(e) {
   ... обрабатываем ошибки ...
} *!*finally*/!* {
   ... выполняем всегда ...
}
```

Попробуйте запустить такой код:

```js run
try {
  alert( 'try' );
  if (confirm('Сгенерировать ошибку?')) BAD_CODE();
} catch (e) {
  alert( 'catch' );
} finally {
  alert( 'finally' );
}
```

У кода два способа выполнения:

1. Если вы ответите на вопрос "Сгенерировать ошибку?" утвердительно, то `try -> catch -> finally`.
2. Если ответите отрицательно, то `try -> finally`.

Секцию `finally` часто используют, чтобы завершить действие начатое еще до `try..catch` при любом случае исхода.

Например, мы хотим измерить время, которое занимает функция чисел Фибоначчи `fib(n)`. Естественно, мы можем начать измерения до того, как функция начнет выполняться и закончить после. Но что делать, если при вызове функции возникла ошибка? В частности, реализация `fib(n)` в приведенном ниже коде возвращает ошибку для отрицательных и для нецелых чисел.

Секция `finally` отлично подходит для завершения измерений несмотря ни на что.

Здесь `finally` гарантирует, что время будет измерено корректно в обеих ситуациях -- в случае успешного завершения `fib` и в случае ошибки:

```js run
let num = +prompt("Введите положительное целое число?", 35)

let diff, result;

function fib(n) {
  if (n < 0 || Math.trunc(n) != n) {
    throw new Error("Должно быть неотрицательным целым числом.");
  }
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

let start = Date.now();

try {
  result = fib(num);
} catch (e) {
  result = 0;
*!*
} finally {
  diff = Date.now() - start;
}
*/!*

alert(result || "возникла ошибка");

alert( `Выполнение заняло ${diff}ms` );
```

Вы можете проверить, запустив этот код и введя `35` в `prompt` -- он завершится нормально, `finally` выполнится после `try`. А затем введите `-1` -- незамедлительно произойдет ошибка, выполнение займет `0ms`. Оба измерения выполняются корректно.

Другими словами, может быть два способа выйти из функции: либо через `return`, либо через `throw`. Секция `finally` обрабатывает и то, и другое.


```smart header="Переменные внутри `try..catch..finally` локальны"
Обратите внимание, что переменные `result` и `diff` в коде выше объявлены *до* `try..catch`.
В противном случае, если бы `let` был использован внутри блока `{...}`, переменные были бы видна только внутри него.
```

````smart header="`finally` и `return`"
Блок `finally` срабатывает при *любом* выходе из `try..catch`, в том числе и `return`.

В примере ниже из `try` происходит `return`, но `finally` получает управление до того, как контроль возвращается во внешний код.

```js run
function func() {

  try {
*!*
    return 1;
*/!*

  } catch (e) {
    /* ... */
  } finally {
*!*
    alert( 'finally' );
*/!*
  }
}

alert( func() ); // сначала срабатывает alert из finally, а затем этот код
```
````

````smart header="`try..finally`"

Конструкция `try..finally` без секции `catch` также полезна. Мы применяем ее, когда не хотим обрабатывать ошибки прямо на месте, но хотим быть уверены, что начатые процессы завершились.

```js
function func() {
  // начать делать что-то, что требует завершения (например, измерения)
  try {
    // ...
  } finally {
    // завершить это даже если все упадет
  }
}
```
В приведенном выше коде, ошибка всегда выпадает наружу, потому что тут нет блока `catch`. Но `finally` отрабатывает до того, как поток управления выпрыгнет наружу.
````

## Глобальный catch

```warn header="Специфично для окружения"
Информация из данной секции не является часть базового JavaScript.
```

Давайте представим, что произошла фатальная ошибка (программная или что-то еще ужасное) снаружи `try..catch`, и скрипт упал.

Существует ли способ отреагировать на такие ситуации? Мы можем захотеть залогировать ошибку, показать что-то пользователю (обычно они не увидят сообщение об ошибке) и т.д.

Такого способа нет в спецификации, но обычно окружения предоставляют его, потому что это весьма полезно. Например, в Node.js для этого есть [process.on('uncaughtException')](https://nodejs.org/api/process.html#process_event_uncaughtexception). И в браузере мы можем присвоить функцию специальному свойству [window.onerror](mdn:api/GlobalEventHandlers/onerror). Она отработает в случае необработанной ошибки.

Синтаксис:

```js
window.onerror = function(message, url, line, col, error) {
  // ...
};
```

`message`
: Сообщение об ошибке.

`url`
: URL скрипта, в котором произошла ошибка.

`line`, `col`
: Номера строки и столбца, в которых произошла ошибка.

`error`
: Объект ошибки.

Пример:

```html run untrusted refresh height=1
<script>
*!*
  window.onerror = function(message, url, line, col, error) {
    alert(`${message}\n В ${line}:${col} на ${url}`);
  };
*/!*

  function readData() {
    badFunc(); // Ой, что-то пошло не так!
  }

  readData();
</script>
```

Роль глобального обработчика `window.onerror` обычно заключается не в восстановление выполнения скрипта -- это скорее всего невозможно в случае программной ошибки, а в отправке сообщение об ошибке разработчикам.

Существуют также веб-сервисы, которые предоставляют логирование ошибок для таких случаев, такие как <https://errorception.com> или <http://www.muscula.com>.

Они работают так:

1. Мы регистрируемся в сервисе и получаем небольшую часть JS (или URL скрипта) от них для вставки на страницы.
2. В этом JS скрипте есть кастомная `window.onerror` функцию.
3. Когда возникает ошибка, он отправляет сетевой запрос о ней в сервис.
4. Мы можем войти в сервисный веб-интерфейс и увидеть ошибки.

## Summary

The `try..catch` construct allows to handle runtime errors. It literally allows to try running the code and catch errors that may occur in it.

The syntax is:

```js
try {
  // run this code
} catch(err) {
  // if an error happened, then jump here
  // err is the error object
} finally {
  // do in any case after try/catch
}
```

There may be no `catch` section or no `finally`, so `try..catch` and `try..finally` are also valid.

Error objects have following properties:

- `message` -- the human-readable error message.
- `name` -- the string with error name (error constructor name).
- `stack` (non-standard) -- the stack at the moment of error creation.

If error is not needed, we can omit it by using `catch {` instead of `catch(err) {`.

We can also generate our own errors using the `throw` operator. Technically, the argument of `throw` can be anything, but usually it's an error object inheriting from the built-in `Error` class. More on extending errors in the next chapter.

Rethrowing is a basic pattern of error handling: a `catch` block usually expects and knows how to handle the particular error type, so it should rethrow errors it doesn't know.

Even if we don't have `try..catch`, most environments allow to setup a "global" error handler to catch errors that "fall out". In-browser that's `window.onerror`.
