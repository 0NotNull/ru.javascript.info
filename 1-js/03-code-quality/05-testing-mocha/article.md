# Автоматическое тестирование c использованием фреймворка Mocha

В последующих заданиях будет использоваться автоматическое тестирование.

Это часть образовательного минимума для разработчика.

## Зачем нам нужны тесты?

Обычно, когда мы пишем функцию, мы легко можем представить, что она должна делать и как она будет вести себя в зависимости от переданных параметров.

Во время разработки мы можем проверить правильность работы функции, просто вызвав ее, например из консоли, и сравнив полученный результат с ожидаемым.

Если функция работает не так, как мы ожидаем, то можно внести исправления в код и запустить её ещё раз. Так можно повторять до тех пор, пока функция не станет работать так, как нам нужно.

Однако, такие ручные проверки -- не лучшее решение.

**При ручном тестировании кода можно легко упустить что-нибудь важное.**

Например, мы работаем над функцией `f`. Написали часть кода и решили протестировать. Выясняется, что `f(1)` работает правильно, в то время как `f(2)` -- нет. Мы вносим в код исправления, и теперь `f(2)` работает правильно. Вроде бы, всё хорошо, не так ли? Однако, мы забыли заново протестировать `f(1)`. Возможно, после внесения правок `f(1)` стала работать неправильно.  

Это типичная ситуация. Во время разработки мы учитываем множество различных сценариев использования. Но сложно ожидать, что программист станет вручную проверять каждый из них после любого изменения кода. Поэтому легко исправить что-то одно и при этом сломать что-то другое.

**Автоматическое тестирование означает, что тесты пишутся по отдельности, в дополнение к коду. Их можно легко запускать, и они проверяют все основные варианты использования.**

## Behavior Driven Development (BDD)

Давайте начнём с техники под названием [Behavior Driven Development](https://ru.wikipedia.org/wiki/BDD_(программирование)).

**BDD – это три в одном: и тесты, и документация, и примеры использования.**

Достаточно слов. Взглянем на пример.

## Разработка функции возведения в степень — "pow": спецификация

Допустим, мы хотим написать функцию `pow(x, n)`, которая возводит `x` в целочисленную степень `n`. Мы предполагаем, что `n≥0`.

Эта задача взята в качестве примера. В JavaScript есть оператор `**`, который служит для возведения в степень. Мы сосредоточимся на процессе разработки, который также можно применять и для более сложных задач.

Перед тем, как начать писать код функции `pow`, мы можем представить себе, что она должна делать, и описать её.

Такое описание называется *спецификацией*, сокращённо *spec* (от анг. *specification*), и выглядит так:

```js
describe("pow", function() {

  it("возводит в степень n", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

Спецификация состоит из трёх основных блоков:

`describe("title", function() { ... })`
: Какой функционал мы описываем. Используется для группировки рабочих лошадок -- блоков `it`. В нашем случае мы описываем функцию `pow`.

`it("description", function() { ... })`
: В первом аргументе блока `it` мы *человеческим языком* описываем конкретный способ использования функции, а во втором -- пишем функцию, которая тестирует данный случай.

`assert.equal(value1, value2)`
: В случае правильной реализации функции для тестируемого случая код внитри блока `it` должен выполняться без ошибок.

    Функции `assert.*` используются для проверки того, что функция `pow` работает так, как мы ожидаем. В этом примере мы используем одну из них -- `assert.equal`, которая сравнивает переданные значения и выбрасывает ошибку, если они не равны друг другу.

    Существуют и другие типы сравнений и проверок. Их мы рассмотрим позднее.

## Процесс разработки

Процесс разработки обычно выглядит следующим образом:

1. Пишется начальная спецификация с тестами, проверяющими основную функциональность.
2. Создаётся начальная реализация.
3. Для запуска тестов мы используем фреймворк [Mocha](http://mochajs.org/) (подробнее о нём чуть позднее). Получаем ошибки. Вносим изменения до тех пор, пока всё не начнёт работать так, как нам нужно.
4. Теперь у нас есть правильно работающая начальная реализация и тесты.
5. Мы добавляем новые способы использования в спецификацию, возможно, ещё не реализованные в трестируемом коде. Тесты начинают *падать*.
6. Возвращаемся на шаг 3, дописываем реализацию до тех пор, пока тесты не начнут завершаться без ошибок.
7. Повторяем шаги 3-6, пока требуемый функционал не будет готов.

Таким образом, разработка проходит *итеративно*. Мы пишем спецификацию, реализуем её, проверяем, что тесты выполняются без ошибок, пишем ещё тесты, снова проверяем, что они проходят и т.д.

В нашем случае первый шаг пройден. У нас есть спецификация для функции `pow`. Давайте напишем реализацию. Перед этим давайте выполним начальный запуск тестов, просто чтобы убедиться, что тесты работают (разумеется, они завершатся ошибками).

## Спецификация в действии

В этой главе мы будем пользоваться следующими JavaScript-библиотеками для тестов:

- [Mocha](http://mochajs.org/) -- основной фреймворк. Он предоставляет общие функции тестирования, такие как `describe` и `it`, а также функцию запуска тестов.
- [Chai](http://chaijs.com) -- библиотека, предоставляющая множество функций проверки утверждений. Пока мы будем использовать только `assert.equal`.
- [Sinon](http://sinonjs.org/) -- библиотека, позволяющая наблюдать за функциями, подражать поведению встроенных функций и многое другое. Нам она пригодится позднее.

Эти библиотеки подходят как для тестирования внутри браузера, так и на стороне сервера. Мы рассмотрим вариант с браузером.

Полная HTML-страница с этим библиотеками и спецификацией функции `pow`:

```html src="index.html"

```

Условно страницу можно разделить на пять частей:

1. Тег `<head>` содержит сторонние библиотеки и стили для тестов.
2. Тег `<script>` содержит тестируемую функцию, в нашем случае -- `pow`.
3. Тесты -- в нашем случае внешний скрипт `test.js`, который содержит спецификацию `describe("pow", ...)`, представленную выше.
4. HTML-элемент `<div id="mocha">` будет использован фреймворком Mocha для вывода результатов тестирования.
5. Запуск тестов производится командой `mocha.run()`.

Результаты:

[iframe height=250 src="pow-1" border=1 edit]

Пока что тест завершается ошибкой. Это логично, потому что у нас пустая функция `pow`, так что `pow(2,3)` возвращает `undefined` вместо `8`.

На будущее отметим, что существуют более продвинутые фреймворки для тестирования, такие как [karma](https://karma-runner.github.io/) и другие. Так что в большинстве случаев не возникает проблем с настройкой разных тестов.

## Начальная реализация

Давайте напишем простую реализацию функции `pow` что бы пройти тесты.

```js
function pow(x, n) {
  return 8; // :) сжульничаем!
}
```

Вау, теперь всё работает!

[iframe height=250 src="pow-min" border=1 edit]

## Улучшаем спецификацию

Конечно, мы сжульничали. Функция не работает. Попытка посчитать `pow(3,4)` даст некорректный результат, однако тесты проходят.

...Такая ситуация вполне типична, она случается на практике. Тесты проходят, но функция работает неправильно. Наша спецификация не идеальна. Мы должны дополнить её тестами.

Давайте добавим ещё один тест, чтобы посмотреть, что `pow(3, 4) = 81`.

Есть два пути организации тестов:

1. Первый -- добавить ещё один `assert` в существующий `it`:

    ```js
    describe("pow", function() {

      it("возводит число в степень n", function() {
        assert.equal(pow(2, 3), 8);
    *!*
        assert.equal(pow(3, 4), 81);
    */!*
      });

    });
    ```
2. Второй -- написать два теста:

    ```js
    describe("pow", function() {

      it("2 в степени 3 будет 8", function() {
        assert.equal(pow(2, 3), 8);
      });

      it("3 в степени 3 будет 27", function() {
        assert.equal(pow(3, 3), 27);
      });

    });
    ```

Принципиальная разница в том, что когда один из `assert` выбрасывает ошибку, то выполнение `it` блока тут же прекращается. Таким образом, если первый `assert` выбросит ошибку, результат работы второго `assert` мы уже не узнаем.

Разделять тесты предпочтительнее, так как мы получаем больше информации о том, что конкретно пошло не так.

Помимо этого есть одно хорошее правило, которому стоит следовать.

**Один тест проверяет одну вещь.**

Если вы посмотрите на тест и увидите в нём две независимые проверки, то такой тест лучше разделить на два более простых.

Давайте продолжим со вторым вариантом.

Результаты:

[iframe height=250 src="pow-2" edit border="1"]

Как мы и ожидали, второй тест провалился. Естественно, наша функция всегда возвращает `8`, в то время как `assert` ожидает `27`.

## Улучшаем реализацию

Давайте напишем что-то более похожее на функцию возведения в степень, чтобы заставить тесты проходить.

```js
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

Чтобы убедиться, что эта реализация работает нормально, давайте протестируем её на большем количестве значений. Чтобы не писать вручную каждый блок `it`, мы можем генерировать их в цикле `for`:

```js
describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} в степени 3 будет ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
```

Результат:

[iframe height=250 src="pow-3" edit border="1"]

## Вложенные блоки describe

Мы собираемся добавить больше тестов. Однако, перед этим стоит сгруппировать вспомогательную функцию `makeTest` и цикл `for`. Нам не нужна функция `makeTest` в других тестах, она нужна только в цикле `for`. Её предназначение -- проверить, что `pow` правильно возводит число в заданную степень.

Группировка производится вложенными блоками `describe`:

```js
describe("pow", function() {

*!*
  describe("возводит x в степень 3", function() {
*/!*

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} в степени 3 будет ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

*!*
  });
*/!*

  // ... другие тесты. Можно писать и describe, и it блоки.
});
```

Вложенные `describe` образуют новую подгруппу тестов. В результатах мы можем видеть дополнительные отступы в названиях.

[iframe height=250 src="pow-4" edit border="1"]

В будущем мы можем написать новые `it` и `describe` блоки на верхнем уровне со своими собственными вспомогательными функциями. Им не будет доступна функция `makeTest` из примера выше.

````smart header="`before/after` и `beforeEach/afterEach`"
Мы можем задать `before/after` функции, которые будут выполняться до/после тестов, а также функции `beforeEach/afterEach`, выполняемые до/после *каждого* `it`.

Например:

```js no-beautify
describe("тест", function() {

  before(() => alert("Тестирование началось – перед тестами"));
  after(() => alert("Тестирование закончилось – после всех тестов"));

  beforeEach(() => alert("Перед тестом – начинаем выпонять тест"));
  afterEach(() => alert("После теста – заначиваем выполнение теста"));

  it('тест 1', () => alert(1));
  it('тест 2', () => alert(2));

});
```

Порядок выполнения будет таким:

```
Тестирование началось – перед тестами (before)
Перед тестом – начинаем выпонять тест (beforeEach)
1
После теста – заначиваем выполнение теста (afterEach)
Перед тестом – начинаем выпонять тест (beforeEach)
2
После теста – заначиваем выполнение теста (afterEach)
Тестирование закончилось – после всех тестов (after)
```

[edit src="beforeafter" title="Откройте пример в песочнице."]

Обычно `beforeEach/afterEach` (`before/after`) используются для инициализации, обнуления счетчиков или чего-нибудь ещё между тестами (или группами тестов).
````

## Расширение спецификации

Основной функционал `pow` реализован. Первая итерация разработки завершена. Когда мы закончим отмечать и пить шампанское, давайте продолжим работу и улучшим наши тесты.

Как было сказано, функция `pow(x, n)` предназначена для работы с целыми положительными значениями `n`.

Для обозначения математических ошибок функции JavaScript обычно возвращают `NaN`. Давайте делать также для некорректных значений `n`.

Сначала давайте опишем это поведение в спецификации.

​```js
describe("pow", function() {

  // ...

  it("для отрицательных n возвращает NaN", function() {
*!*
    assert.isNaN(pow(2, -1));
*/!*
  });

  it("для дробных n возвращает NaN", function() {
*!*
    assert.isNaN(pow(2, 1.5));    
*/!*
  });

});
```

Результаты с новыми тестами

[iframe height=530 src="pow-nan" edit border="1"]

Новые тесты падают, потому что наша реализация не поддержвает их. Так работает BDD. Сначала мы пишем тесты, которые падают, а уже потом пишем под них реализацию.

```smart header="Другие функции сравнения"

Обратите внимание на `assert.isNaN`. Это утверждение позволяет проверить, что переданное в него значение равно `NaN`.

Библиотека Chai содержит множество других подобных функций, например:

- `assert.equal(value1, value2)` -- проверяет равенство  `value1 == value2`.
- `assert.strictEqual(value1, value2)` -- проверяет срогое равенство `value1 === value2`.
- `assert.notEqual`, `assert.notStrictEqual` -- проверяет неравенство и строгое неравенство соответственно.
- `assert.isTrue(value)` -- проверяет истинность значения `value === true`
- `assert.isFalse(value)` -- проверяет ложность значения `value === false`
- ...с полным списком можно ознакомиться в [документации](http://chaijs.com/api/assert/)
```

Итак, нам нужно добавить пару строчек в функцию `pow`:

```js
function pow(x, n) {
*!*
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;
*/!*

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

Теперь работат, все тесты проходят:

[iframe height=300 src="pow-full" edit border="1"]

[edit src="pow-full" title="Открыть готовый пример в песочнице."]

## Итого

В BDD сначала пишут спецификацию, а потом реализацию. В конце у нас есть и то, и другое.

Спецификацию можно использовать тремя способами:

1. **Тесты** гарантируют, что функция работает правильно.
2. **Документация** -- заголовки блоков `describe` и `it` описывают поведение функции.
3. **Примеры** -- тесты, по сути, являются готовыми примерами использования функции.

Имея спецификацию, мы можем улучшить, изменить и даже переписать функцию с нуля, и при этом мы будем уверены, что она продолжает работать правильно.

Это особенно важно в больших проектах, когда одна функция может быть использована во множестве мест. Когда мы вносим в такую функцию изменения, у нас нет никакой возможности вручную проверить, что она продолжает работать правильно во всех местах, где её используют.

Не имея тестов, людям приходится выбирать один их двух путей:

1. Внести изменения, и неважно, что будет. Потом у наших пользователей станут появляться баги, о которых они станут сообщать. Если мы, конечно, можем себе это позволить.
2. Или же люди просто побоятся вносить изменения в такие функции, если наказание за ошибки будет столь суровым. Потом такой код стареет, зарастает паутиной и никто не хочет в него лезть. Это нехорошо.

**Автоматическое тестирование кода против этого!**

Если проект покрыт тестами, то вышеупомянутые проблемы не возникают. Мы можем запустить тесты и увидеть результаты огромного количества проверок, сделанных за секунды.

**Кроме того, код, хорошо покрытый тестами, как правило, имеет лучшую архитектуру.**

Естественно, его легче менять и улучшать. Но не только из-за этого.

Для написания тестов нужно организовать код таким образом, чтобы у каждой функции была ясно поставленная задача и точно определены её аргументы и возвращаемое значение. А это означает, что мы получаем хорошую архитектуру с самого начала.

В реальности это не всегда так просто. Иногда сложно написать спецификацию до того, как будет написана реализация, потому что не всегда чётко понятно, как та или иная функция должна себя вести.

## Что теперь?

Далее по книге мы встретим много задач с тестами, так что вы увидите много практических примеров.

Написание тестов требует хорошего знания JavaScript. Но мы только начали учить его. Не волнуйтесь. Пока вам не нужно писать тесты, но вы уже умеете их читать и поймете даже более сложные примеры, чем те, что были представлены в этой главе.
