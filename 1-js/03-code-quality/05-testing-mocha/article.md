# Автоматическое тестирование c использованием фреймворка Mocha

<<<<<<< HEAD
В последующих заданиях будет использоваться автоматическое тестирование. Также оно часто используется в реальных проектах.

## Зачем нам нужны тесты?
=======
Automated testing will be used in further tasks, and it's also widely used in real projects.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

Обычно, когда мы пишем функцию, мы легко можем представить, что она должна делать и как она будет вести себя в зависимости от переданных параметров.

Во время разработки мы можем проверить правильность работы функции, просто вызвав её, например из консоли, и сравнив полученный результат с ожидаемым.

Если функция работает не так, как мы ожидаем, то можно внести исправления в код и запустить её ещё раз. Так можно повторять до тех пор, пока функция не станет работать так, как нам нужно.

Однако, такие "ручные перезапуски" -- не лучшее решение.

**При тестировании кода ручными перезапусками легко упустить что-нибудь важное.**

Например, мы работаем над функцией `f`. Написали часть кода и решили протестировать. Выясняется, что `f(1)` работает правильно, в то время как `f(2)` -- нет. Мы вносим в код исправления, и теперь `f(2)` работает правильно. Вроде бы, всё хорошо, не так ли? Однако, мы забыли заново протестировать `f(1)`. Возможно, после внесения правок `f(1)` стала работать неправильно.  

Это типичная ситуация. Во время разработки мы учитываем множество различных сценариев использования. Но сложно ожидать, что программист станет вручную проверять каждый из них после любого изменения кода. Поэтому легко исправить что-то одно и при этом сломать что-то другое.

<<<<<<< HEAD
**Автоматическое тестирование означает, что тесты пишутся отдельно, в дополнение к коду. Их можно легко запускать автоматически, и они проверяют все основные варианты использования кода.**
=======
That's very typical. When we develop something, we keep a lot of possible use cases in mind. But it's hard to expect a programmer to check all of them manually after every change. So it becomes easy to fix one thing and break another one.

**Automated testing means that tests are written separately, in addition to the code. They can be executed automatically and check all the main use cases.**
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

## Behavior Driven Development (BDD)

Давайте начнём с техники под названием [Behavior Driven Development](https://ru.wikipedia.org/wiki/BDD_(программирование)).

**BDD – это три в одном: и тесты, и документация, и примеры использования.**

<<<<<<< HEAD
Достаточно слов. Взглянем на пример.
=======
Let's see the example.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

## Разработка функции возведения в степень — "pow": спецификация

Допустим, мы хотим написать функцию `pow(x, n)`, которая возводит `x` в целочисленную степень `n`. Мы предполагаем, что `n≥0`.

Эта задача взята в качестве примера. В JavaScript есть оператор `**`, который служит для возведения в степень. Мы сосредоточимся на процессе разработки, который также можно применять и для более сложных задач.

Перед тем, как начать писать код функции `pow`, мы можем представить себе, что она должна делать, и описать её.

Такое описание называется *спецификацией* (specification), и выглядит так:

```js
describe("pow", function() {

  it("возводит в степень n", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

Спецификация состоит из трёх основных блоков:

`describe("заголовок", function() { ... })`
: Какой функционал мы описываем. Используется для группировки рабочих лошадок -- блоков `it`. В нашем случае мы описываем функцию `pow`.

<<<<<<< HEAD
`it("описание", function() { ... })`
: В первом аргументе блока `it` мы *человеческим языком* описываем конкретный способ использования функции, а во втором -- пишем функцию, которая тестирует данный случай.
=======
`it("use case description", function() { ... })`
: In the title of `it` we *in a human-readable way* describe the particular use case, and the second argument is a function that tests it.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

`assert.equal(value1, value2)`
: Код внутри блока `it`, если функция работает верно, должен выполняться без ошибок.

    Функции вида `assert.*` используются для проверки того, что функция `pow` работает так, как мы ожидаем. В этом примере мы используем одну из них -- `assert.equal`, которая сравнивает переданные значения и выбрасывает ошибку, если они не равны друг другу.

    Существуют и другие типы сравнений и проверок. Их мы рассмотрим позднее.

## Процесс разработки

Процесс разработки обычно выглядит следующим образом:

1. Пишется начальная спецификация с тестами, проверяющими основную функциональность.
2. Создаётся начальная реализация.
3. Для запуска тестов мы используем фреймворк [Mocha](http://mochajs.org/) (подробнее о нём чуть позже). Пока функция не готова, получаем ошибки. Вносим изменения до тех пор, пока всё не начнёт работать так, как нам нужно.
4. Теперь у нас есть правильно работающая начальная реализация и тесты.
5. Мы добавляем новые способы использования в спецификацию, возможно, ещё не реализованные в трестируемом коде. Тесты начинают "падать" (выдавать ошибки).
6. Возвращаемся на шаг 3, дописываем реализацию до тех пор, пока тесты не начнут завершаться без ошибок.
7. Повторяем шаги 3-6, пока требуемый функционал не будет готов.

<<<<<<< HEAD
Таким образом, разработка проходит *итеративно*. Мы пишем спецификацию, реализуем её, проверяем, что тесты выполняются без ошибок, пишем ещё тесты, снова проверяем, что они проходят и т.д.
=======
1. An initial spec is written, with tests for the most basic functionality.
2. An initial implementation is created.
3. To check whether it works, we run the testing framework [Mocha](http://mochajs.org/) (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.
4. Now we have a working initial implementation with tests.
5. We add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.
6. Go to 3, update the implementation till tests give no errors.
7. Repeat steps 3-6 till the functionality is ready.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

Давайте посмотрим этот поток разработки на нашем примере.

<<<<<<< HEAD
Первый шаг завершён. У нас есть спецификация для функции `pow`. Теперь, перед тем как писать реализацию, давайте подключим библиотеки для пробного запуска тестов, просто чтобы убедиться, что тесты работают (разумеется, они завершатся ошибками).
=======
Let's see this development flow in our practical case.

The first step is complete: we have an initial spec for `pow`. Now, before making the implementaton, let's use few JavaScript libraries to run the tests, just to see that they are working (they will all fail).
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

## Спецификация в действии

В этой главе мы будем пользоваться следующими JavaScript-библиотеками для тестов:

- [Mocha](http://mochajs.org/) -- основной фреймворк. Он предоставляет общие функции тестирования, такие как `describe` и `it`, а также функцию запуска тестов.
- [Chai](http://chaijs.com) -- библиотека, предоставляющая множество функций проверки утверждений. Пока мы будем использовать только `assert.equal`.
- [Sinon](http://sinonjs.org/) -- библиотека, позволяющая наблюдать за функциями, эмулировать встроенные функции и многое другое. Нам она пригодится позднее.

Эти библиотеки подходят как для тестирования внутри браузера, так и на стороне сервера. Мы рассмотрим вариант с браузером.

Полная HTML-страница с этим библиотеками и спецификацией функции `pow`:

```html src="index.html"

```

Условно страницу можно разделить на пять частей:

1. Тег `<head>` содержит сторонние библиотеки и стили для тестов.
2. Тег `<script>` содержит тестируемую функцию, в нашем случае -- `pow`.
3. Тесты -- в нашем случае внешний скрипт `test.js`, который содержит спецификацию `describe("pow", ...)`, представленную выше.
4. HTML-элемент `<div id="mocha">` будет использован фреймворком Mocha для вывода результатов тестирования.
5. Запуск тестов производится командой `mocha.run()`.

Результаты:

[iframe height=250 src="pow-1" border=1 edit]

Пока что тест завершается ошибкой. Это логично, потому что у нас пустая функция `pow`, так что `pow(2,3)` возвращает `undefined` вместо `8`.

<<<<<<< HEAD
На будущее отметим, что существуют более высокоуровневые фреймворки для тестирования, такие как [karma](https://karma-runner.github.io/) и другие. С их помощью легко сделать автозапуск множества тестов.
=======
For the future, let's note that there are more high-level test-runners, like [karma](https://karma-runner.github.io/) and others, that make it easy to autorun many different tests.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

## Начальная реализация

Давайте напишем простую реализацию функции `pow`, чтобы пройти тесты.

```js
function pow(x, n) {
  return 8; // :) сжульничаем!
}
```

Вау, теперь всё работает!

[iframe height=250 src="pow-min" border=1 edit]

## Улучшаем спецификацию

Конечно, мы сжульничали. Функция не работает. Попытка посчитать `pow(3,4)` даст некорректный результат, однако тесты проходят.

...Такая ситуация вполне типична, она случается на практике. Тесты проходят, но функция работает неправильно. Наша спецификация не идеальна. Нужно дополнить её тестами.

<<<<<<< HEAD
Давайте добавим ещё один тест, чтобы посмотреть, что `pow(3, 4) = 81`.
=======
Let's add one more test to check that `pow(3, 4) = 81`.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

У нас есть два пути организации тестов:

1. Первый -- добавить ещё один `assert` в существующий `it`:

    ```js
    describe("pow", function() {

      it("возводит число в степень n", function() {
        assert.equal(pow(2, 3), 8);
    *!*
        assert.equal(pow(3, 4), 81);
    */!*
      });

    });
    ```
2. Второй -- написать два теста:

    ```js
    describe("pow", function() {

      it("2 в степени 3 будет 8", function() {
        assert.equal(pow(2, 3), 8);
      });

      it("3 в степени 3 будет 27", function() {
        assert.equal(pow(3, 3), 27);
      });

    });
    ```

Принципиальная разница в том, что когда один из `assert` выбрасывает ошибку, то выполнение `it` блока тут же прекращается. Таким образом, если первый `assert` выбросит ошибку, результат работы второго `assert` мы уже не узнаем.

Разделять тесты предпочтительнее, так как мы получаем больше информации о том, что конкретно пошло не так.

Помимо этого есть одно хорошее правило, которому стоит следовать.

**Один тест проверяет одну вещь.**

Если вы посмотрите на тест и увидите в нём две независимые проверки, то такой тест лучше разделить на два более простых.

Давайте продолжим со вторым вариантом.

Результаты:

[iframe height=250 src="pow-2" edit border="1"]

Как мы и ожидали, второй тест провалился. Естественно, наша функция всегда возвращает `8`, в то время как `assert` ожидает `27`.

## Улучшаем реализацию

Давайте напишем что-то более похожее на функцию возведения в степень, чтобы заставить тесты проходить.

```js
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

Чтобы убедиться, что эта реализация работает нормально, давайте протестируем её на большем количестве значений. Чтобы не писать вручную каждый блок `it`, мы можем генерировать их в цикле `for`:

```js
describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} в степени 3 будет ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
```

Результат:

[iframe height=250 src="pow-3" edit border="1"]

## Вложенные блоки describe

Мы собираемся добавить больше тестов. Однако, перед этим стоит сгруппировать вспомогательную функцию `makeTest` и цикл `for`. Нам не нужна функция `makeTest` в других тестах, она нужна только в цикле `for`. Её предназначение -- проверить, что `pow` правильно возводит число в заданную степень.

Группировка производится вложенными блоками `describe`:

```js
describe("pow", function() {

*!*
  describe("возводит x в степень 3", function() {
*/!*

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} в степени 3 будет ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

*!*
  });
*/!*

  // ... другие тесты. Можно писать и describe, и it блоки.
});
```

Вложенные `describe` образуют новую подгруппу тестов. В результатах мы можем видеть дополнительные отступы в названиях.

[iframe height=250 src="pow-4" edit border="1"]

В будущем мы можем написать новые `it` и `describe` блоки на верхнем уровне со своими собственными вспомогательными функциями. Им не будет доступна функция `makeTest` из примера выше.

````smart header="`before/after` и `beforeEach/afterEach`"
Мы можем задать `before/after` функции, которые будут выполняться до/после тестов, а также функции `beforeEach/afterEach`, выполняемые до/после *каждого* `it`.

Например:

```js no-beautify
describe("тест", function() {

  before(() => alert("Тестирование началось – перед тестами"));
  after(() => alert("Тестирование закончилось – после всех тестов"));

  beforeEach(() => alert("Перед тестом – начинаем выпонять тест"));
  afterEach(() => alert("После теста – заначиваем выполнение теста"));

  it('тест 1', () => alert(1));
  it('тест 2', () => alert(2));

});
```

Порядок выполнения будет таким:

```
Тестирование началось – перед тестами (before)
Перед тестом – начинаем выпонять тест (beforeEach)
1
После теста – заначиваем выполнение теста (afterEach)
Перед тестом – начинаем выпонять тест (beforeEach)
2
После теста – заначиваем выполнение теста (afterEach)
Тестирование закончилось – после всех тестов (after)
```

[edit src="beforeafter" title="Открыть пример в песочнице."]

<<<<<<< HEAD
Обычно `beforeEach/afterEach` и `before/after` используются для инициализации, обнуления счетчиков или чего-нибудь ещё между тестами (или группами тестов).
=======
Usually, `beforeEach/afterEach` and `before/after` are used to perform initialization, zero out counters or do something else between the tests (or test groups).
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af
````

## Расширение спецификации

Основной функционал `pow` реализован. Первая итерация разработки завершена. Когда мы закончим отмечать и пить шампанское, давайте продолжим работу и улучшим `pow`.

Как было сказано, функция `pow(x, n)` предназначена для работы с целыми положительными значениями `n`.

Для обозначения математических ошибок функции JavaScript обычно возвращают `NaN`. Давайте делать также для некорректных значений `n`.

Сначала давайте опишем это поведение в спецификации.

​```js
describe("pow", function() {

  // ...

  it("для отрицательных n возвращает NaN", function() {
*!*
    assert.isNaN(pow(2, -1));
*/!*
  });

  it("для дробных n возвращает NaN", function() {
*!*
    assert.isNaN(pow(2, 1.5));    
*/!*
  });

});
```

Результаты с новыми тестами

[iframe height=530 src="pow-nan" edit border="1"]

Новые тесты падают, потому что наша реализация не поддержвает их. Так работает BDD. Сначала мы пишем тесты, которые падают, а уже потом пишем под них реализацию.

```smart header="Другие функции сравнения"

Обратите внимание на `assert.isNaN`. Это утверждение позволяет проверить, что переданное в него значение равно `NaN`.

Библиотека Chai содержит множество других подобных функций, например:

- `assert.equal(value1, value2)` -- проверяет равенство  `value1 == value2`.
- `assert.strictEqual(value1, value2)` -- проверяет срогое равенство `value1 === value2`.
- `assert.notEqual`, `assert.notStrictEqual` -- проверяет неравенство и строгое неравенство соответственно.
- `assert.isTrue(value)` -- проверяет, что `value === true`
- `assert.isFalse(value)` -- проверяет, что `value === false`
- ...с полным списком можно ознакомиться в [документации](http://chaijs.com/api/assert/)
```

Итак, нам нужно добавить пару строчек в функцию `pow`:

```js
function pow(x, n) {
*!*
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;
*/!*

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

Теперь работат, все тесты проходят:

[iframe height=300 src="pow-full" edit border="1"]

[edit src="pow-full" title="Открыть готовый пример в песочнице."]

## Итого

В BDD сначала пишут спецификацию, а потом реализацию. В конце у нас есть и то, и другое.

Спецификацию можно использовать тремя способами:

1. **Тесты** гарантируют, что функция работает правильно.
2. **Документация** -- заголовки блоков `describe` и `it` описывают поведение функции.
3. **Примеры** -- тесты, по сути, являются готовыми примерами использования функции.

Имея спецификацию, мы можем улучшить, изменить и даже переписать функцию с нуля, и при этом мы будем уверены, что она продолжает работать правильно.

Это особенно важно в больших проектах, когда одна функция может быть использована во множестве мест. Когда мы вносим в такую функцию изменения, у нас нет никакой возможности вручную проверить, что она продолжает работать правильно во всех местах, где её используют.

<<<<<<< HEAD
Не имея тестов, людям приходится выбирать один их двух путей:

1. Внести изменения, и неважно, что будет. Потом у наших пользователей станут проявляться ошибки, ведь мы наверняка что-то забудем проверить вручную.
2. Или же, если наказание за ошибки в коде серьёзное, то люди просто побоятся вносить изменения в такие функции. Код будет стареть, зарастать паутиной и никто не захочет в него лезть. Это нехорошо для разработки.

**Автоматическое тестирование кода позволяет избежать этих проблем!**
=======
1. To perform the change, no matter what. And then our users meet bugs, as we probably fail to check something manually.
2. Or, if the punishment for errors is harsh, as there are no tests, people become afraid to modify such functions, and then the code becomes outdated, no one wants to get into it. Not good for development.

**Automatic testing helps to avoid these problems!**

If the project is covered with tests, there's just no such problem. After any changes, we can run tests and see a lot of checks made in a matter of seconds.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

Если проект покрыт тестами, то вышеупомянутые проблемы не возникают. После любых изменений мы можем запустить тесты и увидеть результаты огромного количества проверок, сделанных за секунды.

<<<<<<< HEAD
**Кроме того, код, хорошо покрытый тестами, как правило, имеет лучшую архитектуру.**
=======
Naturally, that's because auto-tested code is easier to modify and improve. But there's also another reason.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

Это естественно, ведь такой код легче менять и улучшать. Но не только по этой причине.

Для написания тестов нужно организовать код таким образом, чтобы у каждой функции была ясно поставленная задача и точно определены её аргументы и возвращаемое значение. А это означает, что мы получаем хорошую архитектуру с самого начала.

<<<<<<< HEAD
В реальности это не всегда так просто. Иногда сложно написать спецификацию до того, как будет написана реализация, потому что не всегда чётко понятно, как та или иная функция должна себя вести. Но в общем и целом написание тестов делает разработку быстрее, а итоговый продукт более стабильным.

Далее по книге мы встретим много задач с тестами, так что вы увидите много практических примеров.
=======
Later in the tutorial you will meet many tasks with tests baked-in. So you'll see more practical examples.
>>>>>>> b300836f00536a5eb9a716ad2cbb6b8fe97c25af

Написание тестов требует хорошего знания JavaScript. Но мы только начали учить его. Не волнуйтесь. Пока вам не нужно писать тесты, но вы уже умеете их читать и поймете даже более сложные примеры, чем те, что были представлены в этой главе.
