Давайте внимательно посмотрим, что происходит при вызове `speedy.eat("apple")`.

1. Сначала в прототипе (`=hamster`) находится метод `speedy.eat`, а затем он выполняется с `this=speedy` (объект перед точкой).

2. Затем методу `this.stomach.push()` нужно найти свойство `stomach` и вызвать для него `push`. Он ищет `stomach` в `this` (`=speedy`), но ничего не находит.

3. Он идёт по цепочке прототипов и находит `stomach` в `hamster`.

4. И вызывает для него `push`, добавляя еду в *живот прототипа*.

Получается, что у хомяков один живот на двоих!

Каждый раз, когда `stomach` берётся из прототипа, `stomach.push` изменяет его "на месте".

Обратите внимание, что этого не происходит при простом назначении `this.stomach=`:

```js run
let hamster = {
  stomach: [],

  eat(food) {
*!*
    // задать для this.stomach, а не для this.stomach.push
    this.stomach = [food];
*/!*
  }
};

let speedy = {
   __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// Шустрый хомяк нашёл еду
speedy.eat("apple");
alert( speedy.stomach ); // яблоко

// Живот ленивого хомяка пуст
alert( lazy.stomach ); // <ничего>
```

Теперь всё работает правильно, потому что `this.stomach=` не ищет свойство `stomach`. Значение записывается непосредственно в объект `this`.

Также мы можем полностью избежать проблемы, если у каждого хомяка будет собственный живот:

```js run
let hamster = {
  stomach: [],

  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster,
*!*
  stomach: []
*/!*
};

let lazy = {
  __proto__: hamster,
*!*
  stomach: []
*/!*
};

// Шустрый хомяк нашёл еду
speedy.eat("apple");
alert( speedy.stomach ); // яблоко

// Живот ленивого хомяка пуст
alert( lazy.stomach ); // <ничего>
```

Как правило, все свойства, описывающие состояние определённого объекта (как свойство `stomach` в примере выше), записываются в этот объект, что помогает избежать подобных проблем.
