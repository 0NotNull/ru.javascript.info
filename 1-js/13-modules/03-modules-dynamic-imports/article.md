
# Динамические импорты

Инструкции экспорта и импорта, которые мы рассматривали в предыдущей главе, называются "статическими".

Это потому, что они на самом деле статические. Синтаксис совершенно определённый.

Во-первых, мы не можем динамически создавать никакие из параметров `import`.

Путь к модулю должен быть строковым примитивом и не может быть вызовом функции. Вот так работать не будет:

```js
import ... from *!*getModuleName()*/!*; // Ошибка, должна быть "строка"
```

Во-вторых, мы не можем делать импорт в зависимости от условий или в процессе выполнения.

```js
if(...) {
  import ...; // Ошибка, запрещено
}

{
  import ...; // Ошибка, мы не можем ставить импорт в блок инструкций
}
```

Всё это потому, что импорт/экспорт стремится обеспечить костяк структуры кода.

Но как мы можем импортировать модуль динамически, по запросу?

## Функция import()

Функция `import(module)` может быть вызвана из любого места. Она вернёт промис, а он в свою очередь -- объект модуля.

Использовать её мы можем, например вот так:

```js run
let modulePath = prompt("Module path?");

import(modulePath)
  .then(obj => <module object>)
  .catch(err => <loading error, no such module?>)
```

Или, если внутри асинхронной функции, то можно вот так: `let module = await import(modulePath)`.

Как здесь:

[codetabs src="say" current="index.html"]

Так что, использовать динамические импорты очень легко.

Также, динамические импорты работают в обычных скриптах, для них не требуется `script type="module"`.
