**Ответ: ошибка.**

Проверьте:
```js run
function makeUser() {
  return {
    name: "Джон",
    ref: this
  };
};

let user = makeUser();

alert( user.ref.name ); // Error: Cannot read property 'name' of undefined
```

Это потому, что правила, которые определяют значения `this` не воспринимают объектные литералы.

Вот здесь значение `this` внутри `makeUser()` является `undefined`, потому что `makeUser()` вызвано как функция, не как метод.

И литерал объекта сам по себе не влияет на `this`. Значение `this` одно для всей функции, блоков кода и объектные литералы не воздействуют на него.

Таким образом, когда создается объект (который возвращается из функции `makeUser()`) и нужно присвоить значение его свойству `ref` - вычисляется значение `this`, которое берет текущее значение `this` функции `makeUser()`.

Тут противоположный случай:

```js run
function makeUser() {
  return {
    name: "Джон",
*!*
    ref() {
      return this;
    }
*/!*
  };
};

let user = makeUser();

alert( user.ref().name ); // Джон
```

Здесь тоже `makeUser()` вызывается как функция, не как метод. Но теперь это работает, потому что свойство `ref` создаваемого объекта является методом. Теперь это свойство ссылается на код функции, возвращающей `this` - т.е. при возващении созданного объекта, значение `this` уже не вычисляется, поскольку код функции не исполняется, `ref` просто ссылается на этот код. Когда же `ref` вызывается как метод  объекта `user.ref()` - значение `this` внутри метода вычисляется и ссылается на объект, который идет перед точкой `.` (т.е. объект из которого вызывается метод).


