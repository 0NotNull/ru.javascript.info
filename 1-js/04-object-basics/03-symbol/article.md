
# Тип данных Symbol

В спецификации сказано, что в качестве ключей для свойств объекта могут использоваться только строки либо символы. Ни числа, ни логические значения не подходят, разрешены только два типа данных -- строки и символы.

До сих пор мы рассматривали только строки. Теперь давайте разберём символы, их преимущества и особенности.

## Символы

"Символ" представляет собой уникальный идентификатор. 

Создаются новые символы с помощью функции `Symbol()`:

```js
// Создаём новый символ - id  
let id = Symbol();
```

Символу может быть дано описание (также обозначаемое как имя символа), в основном, использующееся для отладки кода: 

```js run
// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");
```

Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание -- это просто ярлык, который ни на что не влияет.

Например, вот два символа с одинаковым описанием -- но они не равны:

```js run
let id1 = Symbol("id");
let id2 = Symbol("id");

*!*
alert(id1 == id2); // false
*/!*
```

Если вы знаете Ruby или какой-то другой язык программирования, в котором есть своего рода "символы" -- пожалуйста, будьте внимательны. Символы в JavaScript имеют свои особенности, и не стоит думать о них, как о символах в Ruby или в других ЯП.

````warn header="Символы не преобразуются автоматически в строки"
Большинство типов данных в JavaScript могут быть неявно преобразованы в строку. Например, функция `alert` принимает практически любое значение, автоматически преобразовывает его в строку, а затем выводит это значение, не сообщая об ошибке. Символы же особенные и не преобразуются автоматически.

К примеру, `alert` ниже выдаст ошибку:

```js run
let id = Symbol("id");
*!*
alert(id); // TypeError: Cannot convert a Symbol value to a string
*/!*
```

Это "защита" языка от путаницы, ведь строки и символы принципиально разные типы данных и не должны неконтролируемо преобразовываться друг в друга.

Если же мы действительно хотим вывести символ с помощью `alert`, то необходимо явно преобразовать его с помощью метода `.toString()`, вот так:
```js run
let id = Symbol("id");
*!*
alert(id.toString()); // Symbol(id), теперь работает
*/!*
```

Или же мы можем обратиться к свойству `symbol.description`, чтобы вывести отдельно описание:
```js run
let id = Symbol("id");
*!*
alert(id.description); // id
*/!*
```

````

## "Скрытые" свойства

Символы позволяют создавать так называемые "скрытые" свойства объектов, к которым невозможно получить доступ из других частей программы или перезаписать.

Например, если мы хотим сохранить некое свойство "идентификатор" для объекта `user`, мы можем использовать символ как ключ для него:

```js run
let user = { name: "Егор" };
let id = Symbol("id");

user[id] = "ID Value";
alert( user[id] ); // мы можем получить доступ к данным по ключу-символу
```

Почему же лучше использовать `Symbol("id")`, а не строку `"id"`?

Давайте немного усложним пример.

Представьте, что другой скрипт для каких-то целей хочет записать собственное свойство "id" в объект `user`. Этот скрипт может быть какой-то JavaScript-библиотекой, абсолютно не связанной с вашим скриптом. 

Сторонний код может создать свой символ `Symbol("id")`:

```js
// ...
let id = Symbol("id");

user[id] = "Другой id";
```

Конфликта не будет, так как символы всегда уникальны, даже если их имена совпадают.

Но если бы использовалась строка `"id"` вместо символа, то тогда *мог бы быть* конфликт:

```js run
let user = { name: "Егор" };

// объявляем в нашем скрипте свойство "id"
user.id = "Наш ID";

// ...и если потом свойство объявляется в другом скрипте...

user.id = "Другой id"
// Опа! Свойство перезаписано! Автор сторонней библиотеки не хотел навредить, но, тем не менее, вышло именно так.
```

### Символы как ключи объектов

Если мы хотим использовать символ как ключ объекта, его необходимо заключить в квадратные скобки.

Вот так:

```js
let id = Symbol("id");

let user = {
  name: "John",
*!*
  [id]: 123 // просто "id: 123" не сработает
*/!*
};
```
Это вызвано тем, что нам нужно получить значение из переменной `id`, а не строку "id".

### Символы игнорируются циклом for..in

Свойства, чьи ключи -- символы, не итерируются циклом `for..in`.

Например:

```js run
let id = Symbol("id");
let user = {
  name: "Егор",
  age: 30,
  [id]: 123
};

*!*
for (let key in user) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)
*/!*

// но если мы напрямую обратимся к свойству через символ, то мы успешно получим его значение 
alert( "Напрямую: " + user[id] );
```

Это часть общей концепции "скрытия" некоторых частей кода для упрощения взаимодействия с ним. Если другой скрипт или библиотека будут перебирать свойства нашего объекта, они не получат неожиданно доступ к нашему "символьному" свойству.

Но [Object.assign](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), в отличие от цикла `for..in`, видит и строковые, и символьные свойства:
 
```js run
let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
```


Здесь нет никакого парадокса или противоречия. Таков замысел. Идея заключается в том, что когда мы клонируем или объединяем объекты, мы обычно хотим скопировать *все* свойства (включая такие свойства с ключами-символами, как, например, `id` в примере выше).

````smart header="Ключи свойств принудительно преобразуются к строке"
Мы можем использовать только строки и символы в качестве ключей свойств. Все другие типы данных будут автоматически преобразованы к строке.

Например, число `0`, будучи использованным как ключ свойства, превратится в строку `"0"`:

```js run
let obj = {
  0: "Тест" // то же самое что и "0": "test"
};

// обе функции `alert` выведут одно и то же свойство (число 0 преобразовывается в строку "0")
alert( obj["0"] ); // Тест
alert( obj[0] ); // Тест (то же свойство)
```
````

## Глобальные символы

Итак, мы установили, что все символы уникальны, даже если их имена совпадают. Но иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью.

Представим ситуацию -- разные части нашего приложения хотят получить доступ к символу `"id"`, подразумевая именно одно и то же свойство.

Для этого существует *глобальный реестр символов*. Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.

Для чтения (или, при отсутствии, создания) «глобального» символа служит конструкция `Symbol.for(key)`.

Её вызов проверяет глобальный реестр, и если в нём есть символ, описанный как `key`, то возвращает его, иначе создает новый символ `Symbol(key)` и записывает его в реестр как `key`.

Например:

```js run
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// создаём другую переменную, хранящую тот же символ
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ 
alert( id === idAgain ); // true
```

Символы, содержащиеся в реестре, называются *глобальными символами*. Если вам нужен символ, доступный везде в коде - используйте глобальные символы.

```smart header="Похоже на Ruby"
В некоторых языках программирования, например, Ruby, на одно имя (описание) приходится один символ, и не может существовать разных символов с одинаковым именем.

В JavaScript, как мы видим, это верно для глобальных символов.
```

### Symbol.keyFor

Для глобальных символов, кроме `Symbol.for(key)`, который ищет символ по имени, существует обратный метод: `Symbol.keyFor(sym)`, который, наоборот, принимает глобальный символ и возвращает его имя.

К примеру: 

```js run
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получим имя для символов
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
```

Внутри метода `Symbol.keyFor` используется глобальный реестр символов для нахождения имени символа. Так что этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт `undefined`.

Например: 

```js run
alert( Symbol.keyFor(Symbol.for("name")) ); // name, глобальный символ

alert( Symbol.keyFor(Symbol("name2")) ); // undefined, ищем описание неглобального символа
```

## Системные символы

Существует множество "системных" символов, использующихся в JavaScript, и мы можем использовать их, чтобы получить более полный контроль над объектами.

Эти символы перечислены в спецификации в таблице [хорошо известных символов](https://tc39.github.io/ecma262/#sec-well-known-symbols):

- `Symbol.hasInstance`
- `Symbol.isConcatSpreadable`
- `Symbol.iterator`
- `Symbol.toPrimitive`
- ...и так далее.

В частности, `Symbol.toPrimitive` позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву. Мы скоро увидим его применение.

С другими системными символами мы тоже скоро познакомимся, когда будем изучать соответствующие особенности языка. 

## Итого

`Символ` - примитивный тип данных, использующийся для создания уникальных идентификаторов.

Символы создаются вызовом функции `Symbol()`, в которую можно передать описание (имя) символа.

Даже если символы имеют одно и то же имя, это разные символы. Если мы хотим, чтобы одноимённые символы были равны, то используем глобальный реестр: вызов `Symbol.for(key)` возвращает (или создает) глобальный символ с `key` в качестве имени. Многократные вызовы команды `Symbol.for` возвращают один и тот же символ.

Символы имеют два основных варианта использования:

1. "Скрытые" свойства объектов.
    Если в коде есть потенциально "конфликтные" места, например, подключённые библиотеки, и мы хотим добавить в некий объект свойство и удостовериться, что это свойство будет защищённым, мы можем создать символ и использовать его как ключ этого свойства. Символьное свойство не итерируется в цикле `for..in`, так что оно не будет случайно затронуто какими-то операциями. Также его нельзя получить напрямую из другого скрипта, ибо другой скрипт не имеет нашего символа. Таким образом, свойство будет защищённым от случайной перезаписи или использования.

    Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

2. Существует множество системных символов, используемых JavaScript, доступных как `Symbol.*`. Мы можем использовать их, чтобы изменять часть встроенных сценариев. Например, в дальнейших главах мы будем использовать `Symbol.iterator` для [итераторов](info:iterable), `Symbol.toPrimitive` для настройки [преобразования объектов в примитивы](info:object-toprimitive) и так далее.

Технически, символы не на 100% скрыты. Существует встроенный метод [Object.getOwnPropertySymbols(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)  -- с его помощью можно получить все свойства объекта с ключом-символом. Также существует метод [Reflect.ownKeys(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys), который возвращает *все* ключи объекта, включая символьные. Так что, они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций придерживаются соглашения о том, что они таковыми являются. И тот, кто явно использует вышеперечисленные методы, вероятно, прекрасно понимает, что он делает.
