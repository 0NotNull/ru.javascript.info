# Снова стрелочные функции

Давайте вернемся к стрелочным функциям.

Стрелочные функции это не просто "сокращение" чтобы меньше писать.

При написании JavaScript кода часто возникают ситуации когда нам нужно написать небольшую функцию, которая будет выполнена где-то еще. 

Например:

- `arr.forEach(func)` -- `func` выполнена `forEach` для каждого элемента массива.
- `setTimeout(func)` -- `func` выполнена встроенным планировщиком.
- ...и так далее.

Это очень в духе JavaScript, создать функцию и передать ее куда-нибудь.

И в таких функциях мы обычно не хотим выходить из текущего контекста.

## У стрелочных функций нет "this"

Как мы помним из главы <info:object-methods>, у стрелочных функций нет `this`. Если к «this» обращаются, он берется снаружи.

Например, мы можем использовать это для итерации внутри метода объекта:

```js run
let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
*!*
    this.students.forEach(
      student => alert(this.title + ': ' + student)
    );
*/!*
  }
};

group.showList();
```

Здесь внутри `forEach` использована стрелочная функции, таким образом `this.title` в ней будет иметь точно такой же значение как и в методе `showList`: `group.title`.

Если бы мы использовали "обычную" функцию, была бы ошибка:

```js run
let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
*!*
    this.students.forEach(function(student) {
      // Error: Cannot read property 'title' of undefined
      alert(this.title + ': ' + student)
    });
*/!*
  }
};

group.showList();
```

Ошибка возникает потому что `forEach` по умолчанию запускает функции с `this` равным undefined, и мы пытаемся обратиться к `undefined.title`.


Это не влияет на стрелочные функции, потому что у них просто нет `this`

```warn header="Стрелочные функции нельзя использовать с `new`"
Отсутствие`this` естественно ведет к другому ограничению: стрелочные функции не могут быть использованы как конструкторы. Они не могут быть вызваны с `new`.
```

```smart header="Стрелочные функции VS bind"
Существует тонкая разница между стрелочной функцией `=>` and обычной функцией вызванной с `.bind(this)`:

- `.bind(this)` создает "связанную версию" функции.
- Стрелка `=>` ничего не привязывает. У функции просто нет `this`. Определние `this` происходит абсолютно так же как и обычный поиск перменной: во внешнем лексическом окружении.
```

## Стрелочные функции не имеют "arguments"

У стрелочных функции так же нет переменной `arguments`.

Это отлично подходит для декораторов, когда нам нужно пробросить вызов с текущимим `this` и `arguments`.

Например, `defer(f, ms)` принимает функцию и возвращет обертку вокруг нее, которая откладывает вызов на `ms` миллисекунд:

```js run
function defer(f, ms) {
  return function() {
    setTimeout(() => f.apply(this, arguments), ms)
  };
}

function sayHi(who) {
  alert('Hello, ' + who);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred("John"); // Hello, John after 2 seconds
```

Тоже самое без стрелочной функции выглядело бы:

```js
function defer(f, ms) {
  return function(...args) {
    let ctx = this;
    setTimeout(function() {
      return f.apply(ctx, args);
    }, ms);
  };
}
```

Здесь мы были вынуждены создать дополнительные переменные `args` и `ctx` чтобы функция внутри `setTimeout` могла взять их.

## Кратко

Стрелочные функции:

- Не имеют `this`.
- Не имеют `arguments`.
- Не могут быть вызваны `new`.
- (У них так же нет `super`, но мы про это не говорили. Про это будет в главе <info:class-inheritance>).

Все это потому что они предназначены для небольших участков кода которые не имеют своего "контекста", а работают в текущем. И они отлично справляются со всоей задачей.