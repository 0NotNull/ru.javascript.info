
# Синтаксис "new Function"

Существует ещё один вариант объявлять функции. Он используется крайне редко, но иногда другого решения не найти.

## Синтаксис

Синтаксис для объявления функции:

```js
let func = new Function ([arg1[, arg2[, ...argN]],] functionBody)
```

Другими словами, параметры функции (или, если точнее, их имена) идут первыми аргументами, тело функции - последним. Обратите внимание на то, что всё аргументы это строки.

Это проще понять на следующем примере. Здесь объявлена функция с двумя аргументами:

```js run
let sum = new Function('a', 'b', 'return a + b');

alert( sum(1, 2) ); // 3
```

Если у функции нет аргументов, тогда необходимо объявить только один аргумент - тело функции:

```js run
let sayHi = new Function('alert("Hello")');

sayHi(); // Hello
```

Главное отличие от других способов объявления функции, которые были рассмотрены ранее, заключается в том, что функция создаётся полностью «на лету» из строки.

Всё предыдущие объявления требовали от нас, программистов, писать объявление функции в скрипте.

Но `new Function` позволяет превратить любую строку в функцию. Например, мы можем получить новую функцию с сервера и затем выполнить ее:

```js
let str = ... код, полученный с сервера динамически ...

let func = new Function(str);
func();
```

Это используется в очень специфических случаях, например, когда мы получаем код с сервера для динамической компиляции функции. Необходимость в этом возникает на продвинутых этапах разработки.

## Замыкание

Обычно функция помнит, где родилась, в специальном свойстве `[[Environment]]`. Это ссылка на Лексическое окружение (Lexical Environment), в котором она создана.

Но когда функция создаётся используя `new Function`, её `[[Environment]]` - это ссылка не на текущее Лексическое окружение, а на глобальное.

```js run

function getFunc() {
let value = "test";

*!*
let func = new Function('alert(value)');
*/!*

return func;
}

getFunc()(); // ошибка: значение не определено
```

Сравним это с обычным объявлением:

```js run
function getFunc() {
let value = "test";

*!*
let func = function() { alert(value); };
*/!*

return func;
}

getFunc()(); // *!*"test"*/!*, из лексического окружения функции getFunc
```

Эта особенность `new Function` выглядит странно, но оказывается очень полезной на практике.

Представь, что мы должны создать функцию из строки. Код этой функции не известен во время написания скрипта (поэтому не используем обычно объявление функций), но будет известно только в процессе выпаолнения. Мы можем полчить её с сервера или другого ресурса.

Наша новая функция должна взаимодействовать с основным скриптом.

А что, если мы хотим, чтобы она имела доступ к внешним локальным переменным родителя?

Проблема в том, что до развёртывания/публикации JavaScript кода на продакшене, код сжимается с помощью *минификатора (minifier)* - специальная программа, которая сокращает код, удаляя комментарии, лишние пробелы, и, что самое главное, переименовывает локальные переменные в более короткие.

Например, если в функции объявляется переменная `let userName`, то минификатор изменяет её на `let a` (или другую букву, если она не занята), и изменяет её везде. Обычно так делать безопасно, потому что переменная является локальной и никто снаружи не имеет к ней достп. И внутри функции минификатор заменяет каждое её упоминание. Минификаторы достаточно умные. Они не просто "тупой" поиск-замена, они анализируют структуру кода, и поэтому ничего не ломают.

Но, если `new Function` может получить доступ к внешним локальным переменным родителя, то она не сможет найти `userName`, так как она выполняется *после* минификации кода.

**Даже если бы мы могли получить доступ к внешнему лексическому окружению `new Function`, у нас были бы проблемы с миниификаторами.**

"Особое свойство" `new Function` бережёт нас от ошибок.

Это обеспечивает лучший код. Если нам необходимо что-то передать функции, объявленной через `new Function`, мы должны передать это явно, как аргумент.

Наша "sum" функция, на самом деле, делает это правильно:

```js run
*!*
let sum = new Function('a', 'b', 'return a + b');
*/!*

let a = 1, b = 2;

*!*
// Внешние значения переданы как аргументы
alert( sum(a, b) ); // 3
*/!*
```

## Итого

Синтаксис:

```js
let func = new Function(arg1, arg2, ..., body);
```

Аршументы, по историческим причинам, также могут быть объявлены через запятую в одной строке.

Эти 3 примера ниже эквивалентны:

```js
new Function('a', 'b', 'return a + b'); // стандартный синтаксис
new Function('a,b', 'return a + b'); // через запятую в одной строке
new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке
```

Функции, объявленные через `new Function`, имеют `[[Environment]]` ссылающийся на глобыльное Лексическое окружение, не на родительское. Следовательно, они не могут использовать внешние локальные переменные родителя. Но это, на самом деле, хорошо, потому что это избавляет нас от ошибок. Переданные параметры явно являются лучшим архитектурным решением и это не вызывает проблем у минификаторов.

