
# Синтаксис "new Function"

Существует ещё один вариант объявлять функции. Он используется крайне редко, но иногда другого решения не найти.

## Синтаксис

Синтаксис для объявления функции:

```js
let func = new Function ([arg1[, arg2[, ...argN]],] functionBody)
```

Другими словами, параметры функции (или, если точнее, их имена) идут первыми аргументами, тело функции - последним. Обратите внимание на то, что всё аргументы это строки.

Это проще понять на следующем примере. Здесь объявлена функция с двумя аргументами:

```js run
let sum = new Function('a', 'b', 'return a + b');

alert( sum(1, 2) ); // 3
```

Если у функции нет аргументов, тогда необходимо объявить только один аргумент - тело функции:

```js run
let sayHi = new Function('alert("Hello")');

sayHi(); // Hello
```

Главное отличие от других способов объявления функции, которые были рассмотрены ранее, заключается в том, что функция создаётся полностью «на лету» из строки.

Всё предыдущие объявления требовали от нас, программистов, писать объявление функции в скрипте.

Но `new Function` позволяет превратить любую строку в функцию. Например, можно получить новую функцию с сервера и затем выполнить ее:

```js
let str = ... код, полученный с сервера динамически ...

let func = new Function(str);
func();
```

Это используется в очень специфических случаях, например, когда мы получаем код с сервера для динамической компиляции функции. Необходимость в этом возникает на продвинутых этапах разработки.

## Замыкание

Обычно функция помнит, где родилась, в специальном свойстве `[[Environment]]`. Это ссылка на лексическое окружение (Lexical Environment), в котором она создана.

Но когда функция создаётся с использованием `new Function`, её `[[Environment]]` - это ссылка не на текущее лексическое окружение, а на глобальное.

```js run

function getFunc() {
  let value = "test";

  *!*
  let func = new Function('alert(value)');
  */!*

  return func;
}

getFunc()(); // ошибка: значение не определено
```

Сравним это с обычным объявлением:

```js run
function getFunc() {
  let value = "test";

  *!*
  let func = function() { alert(value); };
  */!*

  return func;
}

getFunc()(); // *!*"test"*/!*, из лексического окружения функции getFunc
```

Эта особенность `new Function` выглядит странно, но оказывается очень полезной на практике.

Представьте, что нужно создать функцию из строки. Код этой функции неизвестен во время написания скрипта (вот поэтому не используем обычные функции), а будет определен только в процессе выполнения. Мы можем получить код с сервера или другого ресурса.

Наша новая функция должна взаимодействовать с основным скриптом.

А что, если мы хотим, чтобы она имела доступ к внешним локальным переменным родителя?

Проблема в том, что до развёртывания/публикации JavaScript кода на продакшене, код сжимается с помощью *минификатора (minifier)* - специальная программа, которая сокращает код, удаляя комментарии, лишние пробелы, и, что самое главное, переименовывает локальные переменные в более короткие.

Например, если в функции объявляется переменная `let userName`, то минификатор изменяет её на `let a` (или другую букву, если она не занята), и изменяет её везде. Обычно так делать безопасно, потому что переменная является локальной и никто снаружи не имеет к ней достп. И внутри функции минификатор заменяет каждое её упоминание. Минификаторы достаточно умные. Они не просто "тупой" поиск-замена, они анализируют структуру кода, и поэтому ничего не ломают.

Но если `new Function` может получить доступ к внешним локальным переменным родителя, то она не сможет найти `userName`, так как она выполняется *после* минификации кода.

**Даже если бы мы могли получить доступ к внешнему лексическому окружению `new Function`, у нас были бы проблемы с миниификаторами.**

"Особое свойство" `new Function` бережёт нас от ошибок.

Это обеспечивает лучший код. Если нам необходимо что-то передать функции, объявленной через `new Function`, мы должны передать это явно, как аргумент.

Наша функция "sum" на практике работает, как ожидается:

```js run
*!*
let sum = new Function('a', 'b', 'return a + b');
*/!*

let a = 1, b = 2;

*!*
// Внешние значения переданы как аргументы
alert( sum(a, b) ); // 3
*/!*
```

## Итого

Синтаксис:

```js
let func = new Function(arg1, arg2, ..., body);
```

По историческим причинам аргументы также могут быть объявлены через запятую в одной строке.

Эти 3 примера ниже эквивалентны:

```js
new Function('a', 'b', 'return a + b'); // стандартный синтаксис
new Function('a,b', 'return a + b'); // через запятую в одной строке
new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке
```

Функции, объявленные через `new Function`, имеют `[[Environment]]` ссылающийся на глобальное лексическое окружение, а не на родительское. Следовательно, они не могут использовать внешние локальные переменные родителя. Но это очень хорошо, потому что это избавляет нас от ошибок. Переданные явно параметры - гораздо лучшее архитектурное решение, которое не вызывает проблем у минификаторов.

