
# Глобальный объект

Глобальный объект предоставляет переменные и функции, доступные в любом месте программы. В основном те, что встроены в язык или среду исполнения.

В браузере он называется "window", в Node.js — "global", в другой среде исполнения может называться иначе.

Например, вызовем `alert` как метод `window`:

```js run
alert("Привет");

// то же самое, что и
window.alert("Привет");
```

Мы можем ссылаться на другие встроенные функции, к примеру, `Array` так: `window.Array`. Или создавать свои собственные свойства глобального объекта.

## Браузер: объект "window"

По историческим причинам браузерный объект `window` выглядит слегка запутанно.

1. Он предоставляет инструменты для работы с окном браузера, а также играет роль глобального объекта.

    Можно использовать `window` для доступа к свойствам и методам характерным для окна браузера:

    ```js run
    alert(window.innerHeight); // выводит высоту окна браузера

    window.open('http://google.com'); // открывает новое окно браузера
    ```

2. Если переменные, объявленные с помощью `var`, или функции типа Function Declaration находятся на верхнем уровне программы, то они автоматически становятся свойствами `window`.

    Например:
    ```js untrusted run no-strict refresh
    var x = 5;

    alert(window.x); // 5 (var x становится свойством window)

    window.x = 0;

    alert(x); // 0, переменная изменена
    ```

    Обратите внимание, что этого не происходит с более современными объявлениями `let/const`:

    ```js untrusted run no-strict refresh
    let x = 5;

    alert(window.x); // undefined ("let" не создаёт свойства window)
    ```

3. Кроме того, все скрипты имеют общую глобальную область видимости, поэтому переменные, объявленные в одном теге `<script>`, становятся доступными в других:

    ```html run
    <script>
      var a = 1;
      let b = 2;
    </script>

    <script>
      alert(a); // 1
      alert(b); // 2
    </script>
    ```

4. Мелочь, но всё же стоит сказать, что значение `this` в глобальной области видимости — `window`.

    ```js untrusted run no-strict refresh
    alert(this); // window
    ```

Почему так? На момент создания языка объединение различных данных в одном объекте `window` должно было "упростить" работу. Но с тех пор многое изменилось. Крошечные скрипты превратились в крупные приложения, требующие правильной архитектуры.

Хорошо ли, что разные скрипты (возможно, из разных источников) "видят" переменные друг друга?

Нет, потому что это может привести к конфликту имён: если одинаковые имена переменных используются двумя скриптами — эти переменные будут конфликтовать между собой.

Сейчас "многоцелевой" `window` считается ошибкой проектирования языка.

К счастью, есть "дорога из ада" — JavaScript-модули.

Если мы назначим тегу `<script>` атрибут `type="module"`, такой скрипт будет считаться отдельным модулем с собственной областью видимости верхнего уровня (лексическим окружением), не пересекающейся с `window`.

- В модуле `var x` не станет свойством `window`:

    ```html run
    <script type="module">
      var x = 5;

      alert(window.x); // undefined
    </script>
    ```

- Два модуля, которые не "видят" переменные друг друга:

    ```html run
    <script type="module">
      let x = 5;
    </script>

    <script type="module">
      alert(window.x); // undefined
      alert(x); // Ошибка: переменная не объявлена
    </script>
    ```

- И последнее: в модуле значение `this` на верхнем уровне равно `undefined` (действительно, почему должно быть `window`?):

    ```html run
    <script type="module">
      alert(this); // undefined
    </script>
    ```

**Использование `<script type="module">` исправляет недостаток проектирования языка, отделяя область видимости верхнего уровня от `window`.**

Мы рассмотрим другие свойства модулей позже в главе [](info:modules).

## Допустимое использование глобального объекта

1. Обычно не рекомендуется использовать глобальные переменные. Желательно применять их как можно реже. Однако, если нужно поместить что-либо в глобальную область видимости, мы можем добавить это в `window` (или `global` в Node.js).

    Поместим информацию о текущем пользователе в глобальный объект, чтобы она была доступна другим скриптам:

    ```js run
    // явное назначение свойства `window`
    window.currentUser = {
      name: "John",
      age: 30
    };

    // далее, где угодно в другом скрипте
    alert(window.currentUser.name); // John
    ```

2. Мы можем проверить, поддерживает ли глобальный объект современные возможности языка.

    Например, проверить наличие встроенного объекта `Promise` (такая поддержка отсутствует в очень старых браузерах):
    ```js run
    if (!window.Promise) {
      alert("Ваш браузер очень старый!");
    }
    ```

3. Мы можем создать полифил: добавить функции, которые не поддерживаются окружением (скажем, старым браузером), но существуют в современном стандарте.

    ```js run
    if (!window.Promise) {
      window.Promise = ... // собственная реализация современной возможности языка
    }
    ```

...И, конечно, если в браузере мы используем `window` для доступа к функциям окна браузера (не глобального объекта) — это вполне нормально.
