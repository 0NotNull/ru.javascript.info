
# Глобальный объект

Глобальный объект предоставляет переменные и функции, доступные в любом месте программы. В основном те, что встроены в язык или среду исполнения.

В браузере он назыается "window", в Node.js — "global", в другой среде исполнения может называться иначе.

Например, вызовем `alert` как метод `window`:

```js run
alert("Привет");

// тоже самое что и
window.alert("Привет");
```

Мы можем ссылаться на другие встроенные функции, к примеру, `Array` так `window.Array` или создавать свои собственные свойства глобального объекта.

## Браузер: объект "window"

По историческим причинам, браузерный объект `window` выглядит слегка запутанно.

1. Он предоставляет инструменты для работы с окном браузера, а также играет роль глобального объекта.

    Можно использовать `window` для доступа к свойствам и методам характерным для окна браузера:

    ```js run
    alert(window.innerHeight); // выводит высоту окна браузера

    window.open('http://google.com'); // открывает новое окно браузера
    ```

2. Если переменные, объявленные с помощью `var` или декларации функиций находятся на верхнем уровне программы, то они автоматически становятся свойствами `window`.

    Например:
    ```js untrusted run no-strict refresh
    var x = 5;

    alert(window.x); // 5 (var x становится свойством window)

    window.x = 0;

    alert(x); // 0, переменная изменена
    ```

    Обратите внимание, что этого не происходит с более современными `let/const` объявлениями:

    ```js untrusted run no-strict refresh
    let x = 5;

    alert(window.x); // undefined ("let" не создаёт свойства window)
    ```

3. Кроме того, все скрипты имеют общую глобальную область видимотси, поэтому переменные, объявленные в одном теге `<script>` становятся доступными в других:

    ```html run
    <script>
      var a = 1;
      let b = 2;
    </script>

    <script>
      alert(a); // 1
      alert(b); // 2
    </script>
    ```

4. Мелочь, но всё же, значение `this` в глобальной области видимости — `window`.

    ```js untrusted run no-strict refresh
    alert(this); // window
    ```

Почему так? На момент создания языка, объединение нескольких аспектов в одном объекте `window`, должно было "упростить" работу. Но с тех пор многое изменилось. Крошечные скрипты превратились в крупные приложения, требующие правльной архитектуры.

Хорошо ли, что разные скрипты (возможно из разных источников) "видят" переменные друг друга?

Нет, потому что это может привести к конфликту имён: одинаковые имена переменных могут использоваться двумя скриптами для различных целей и эти переменные будут конфликтовать между собой.

Сейчас, многоцелевой `window` считается ошибкой проектирования языка.

К счастью, есть "дорога из ада" — JavaScript модули.

Если мы установим тегу `<script>` атрибут `type="module"`, такой скрипт будет считаться отдельным модулем сосбственной областью видимости верхнего уровня (лексическим окружением) не пересекающейся с `window`.

- В модуле `var x` не станет свойством `window`:

    ```html run
    <script type="module">
      var x = 5;

      alert(window.x); // undefined
    </script>
    ```

- Два модуля, которые не видят переменные друг друга:

    ```html run
    <script type="module">
      let x = 5;
    </script>

    <script type="module">
      alert(window.x); // undefined
      alert(x); // Ошибка: переменная не объявлена
    </script>
    ```

- И последнее, в модуле значение `this` на верхнем уровне равно `undefined` (действительно, почему должно быть `window`?):

    ```html run
    <script type="module">
      alert(this); // undefined
    </script>
    ```

**Используйте `<script type="module">`, чтобы исправить недостаток проектирования языка, отделяя область видимости верхнего уровня от `window`.**

Мы рассмотрим другие свойства модулей позже в главе [](info:modules).

## Допустимое использование глобального объекта

1. Обычно не рекомендуется использовать глобальные переменные. Желатьльно, применать как можно мешьше таких переменных. Однако, если нужно поместить что-либо в глобальную область видимости, мы можем захотеть добавить это в `window` (или `global` в Node.js).

    Мы помещаем информацию о текущем пользователе в глобальный объект, чтобы она была доступна другим скриптам:

    ```js run
    // явное назначение свойства `window`
    window.currentUser = {
      name: "John",
      age: 30
    };

    // далее, где угодно в другом скрипте
    alert(window.currentUser.name); // John
    ```

2. Мы можем проверить, поддерживает ли глобальный объект современные возможности языка.

    Например, проверить наличие встроенного объекта `Promise` (такая поддержка отсутствует в очень старых браузерах):
    ```js run
    if (!window.Promise) {
      alert("Ваш браузер очень старый!");
    }
    ```

3. Мы можем создать полифилл: добавить функции, которые не поддерживаются окружением (скажем, старым браузером), но сущеcтвуют в современном стандарте.

    ```js run
    if (!window.Promise) {
      window.Promise = ... // собственная реализация современной возможности языка
    }
    ```

...И конечно, если в браузере мы используем `window` для доступа к функциям окна браузера (не как глобального объекта) это вполне нормально.
