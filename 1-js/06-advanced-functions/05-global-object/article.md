
# Глобальный объект

Глобальный объект предоставляет переменные и функции, доступные в любом месте программы. В основном те, что встроены в язык или среду исполнения.

В браузере он называется "window", в Node.js — "global", в другой среде исполнения может называться иначе.

Недавно `globalThis` был добавлен в язык как стандартизированное имя для глобального объекта, которое должно поддерживаться в любом окружении. В некоторых браузерах, с движком отличным от Chromium, `globalThis` ещё не поддерживается, но легко реализуется с помощью полифила.

Все свойства глобального объекта могут быть достигнуты на прямую:

```js run
alert("Привет");

// то же самое, что и
window.alert("Привет");
```

В браузере, глобальные переменные, объявленные, с помощью `var`, становятся свойствами глобального объекта:

```js run untrusted refresh
var gVar = 5;

alert(window.gVar); // 5 (становится свойством глобального объекта)
```

Пожалуйста, не полагайтесь на это. Подобное существует для совместимости. В современных сценариях, использующих JavaScript-модули, такого не происходит. Мы разберём их позже в главе  [](info:modules).

Кроме того, более новые объявления переменных `let` и `const`, вообще, не проявляют такого поведения:

```js run untrusted refresh
let gLet = 5;

alert(window.gLet); // undefined (не становится свойством глобального объекта)
```

Если свойство настольно важное, что вы хотите сделать его доступным глобально, запишите его напрямую, как свойство глобального объекта:

```js run
*!*
// сделать информацию о текущем пользователе глобальной, для предоставления доступа к ней всем скриптам
window.currentUser = {
  name: "John"
};
*/!*

// где угодно в коде
alert(currentUser.name); // John

// или, если у нас есть локальная переменная с именем "value",
// полумим её из window явно (безопасно!)
alert(window.currentUser.name); // John
```

Тем не менее, обычно не рекомендуется использовать глобальные переменные. Следует применять их как можно реже. Скрипт, где на вход функция получает переменные и выдаёт определённый результат, чище, надёжней и удобней для тестирования.

## Использование полифилов

Мы можем проверить, поддерживает ли глобальный объект современные возможности языка.

    Например, проверить наличие встроенного объекта `Promise` (такая поддержка отсутствует в очень старых браузерах):
    ```js run
    if (!window.Promise) {
      alert("Ваш браузер очень старый!");
    }
    ```

Если нет (скажем, используется старый браузер), мы можем создать полифил: добавить функции, которые не поддерживаются окружением, но существуют в современном стандарте.

```js run
if (!window.Promise) {
  window.Promise = ... // собственная реализация современной возможности языка
}
```

## Итого

- Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.

    Это включает в себя как встроенные конструкции, например, `Array`, так и характерные для окружения свойства, например, `window.innerHeight` -- высота окна браузера.
- Глобальный объект имеет универсальное имя -- `globalThis`.

    ...Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как `window` (браузер) и `global` (Node.js). Так как `globalThis` появился недавно, он не поддерживается браузерами, созданными не на движке Chromium (можно использовать полифил).
- Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться свести их количество к минимуму.
- В браузерах, если только мы не используем [modules](info:modules), глобальные переменные, объявленные с помощью `var`, становятся свойствами глобального объекта.

    Для того, чтобы код был проще и его легче было поддерживать в будущем, следует обращаться к свойствам глобального объекта напрямую: `window.x = ...` вместо `var x = ...`.
