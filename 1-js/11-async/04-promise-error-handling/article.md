
# Промисы: обработка ошибок

Иногда при выполнении асинхронного кода могут возникать ошибки: соответствующий промис будет отклонён. Например, если удалённый сервер не доступен, то `fetch` вернёт ошибку. Мы можем использовать `.catch`, чтобы перехватывать эти ошибки (отклонённые промисы).

Для перехватывания ошибок хорошо подходят цепочки промисов. Если промис будет отклонён, то управление над промисом переходит в ближайший перехватчик, дальше по цепочке. Это очень удобно на практике.

Например, в представленном ниже примере указана неправильная ссылка (сервер не существует) и `.catch` перехватывает ошибку:

```js run
*!*
fetch('https://no-such-server.blabla') // ошибка
*/!*
  .then(response => response.json())
  .catch(err => alert(err)) // TypeError: failed to fetch (текст может отличаться)
```

Или, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON:

```js run
fetch('/') // сейчас fetch выполнится, сервер успешно отвечает
*!*
  .then(response => response.json()) // ошибка: HTML-страница вместо ожидаемой json-строки
*/!*
  .catch(err => alert(err)) // SyntaxError: Unexpected token < in JSON at position 0
```

Самый лёгкий путь, перехватить все ошибки - добавить `.catch` в конец цепочки:

```js run
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise((resolve, reject) => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
*!*
  .catch(error => alert(error.message));
*/!*
```

Так как здесь нет ошибок, то `.catch` вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.

## Неявный try..catch

Вокруг промисов и обработчиков промисов встроен "скрытый `try..catch`". Если происходит ошибка, то он перехватывает её и рассматривает как отклонённый промис.

Например, этот код:

```js run
new Promise((resolve, reject) => {
*!*
  throw new Error("Whoops!");
*/!*
}).catch(alert); // Error: Whoops!
```

...Работает так же, как и этот:

```js run
new Promise((resolve, reject) => {
*!*
  reject(new Error("Whoops!"));
*/!*  
}).catch(alert); // Error: Whoops!
```

"Скрытый `try..catch`", вокруг промиса, автоматически перехватывает ошибку и рассматривает её как отклонённый промис.

Это работает не только в промисе, но и в обработчиках. Если мы пробросим ошибку (`throw`) из обработчика (`.then`), то управление переходит к ближайшему обработчику ошибок, промис будет рассматриваться как отклонённый.

Пример:

```js run
new Promise((resolve, reject) => {
  resolve("ok");
}).then((result) => {
*!*
  throw new Error("Whoops!"); // пробрасываем ошибку
*/!*
}).catch(alert); // Error: Whoops!
```

Это работает не только для `throw`, но и для любых ошибок, включая программные ошибки:

```js run
new Promise((resolve, reject) => {
  resolve("ok");
}).then((result) => {
*!*
  blabla(); // нет такой функции
*/!*
}).catch(alert); // ReferenceError: blabla is not defined
```

Как побочный эффект, финальный `.catch` не только перехватывает явно отклонённые промисы, но и случайные ошибки в обработчиках выше.

## Повторное пробрасывание ошибок (rethrowing)

Как мы уже заметили, `.catch` ведёт себя как `try..catch`. У нас может быть столько обработчиков `.then`, сколько мы хотим, и затем использовать один `.catch`, в конце, чтобы перехватить ошибки из всех обработчиков.

В обычном `try..catch` мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.

Если мы пробросим (`throw`) ошибку внутри блока `.catch`, то управление перейдет к следующему ближайшему обработчику ошибок. И если мы обработаем ошибку, и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик `.then`.

В примере ниже, `.catch` успешно обрабатывает ошибку:

```js run
// the execution: catch -> then
new Promise((resolve, reject) => {

  throw new Error("Whoops!");

}).catch(function(error) {

  alert("Ошибка обработана, продолжить работу");

}).then(() => alert("Следующий успешный запуск обработчика"));
```

Здесь блок `.catch` завершается нормально. Поэтому вызывается следующий успешный обработчик `.then`.

В примере ниже мы видим другую ситуацию с блоком `.catch`. Обработчик `(*)` перехватывает ошибку и не может обработать её (например, он знает как обработать только `URIError`), поэтому ошибка пробрасывается снова:

```js run
// the execution: catch -> catch -> then
new Promise((resolve, reject) => {

  throw new Error("Whoops!");

}).catch(function(error) { // (*)

  if (error instanceof URIError) {
    // обрабатываем ошибку
  } else {
    alert("Не могу обработать ошибку");

*!*
    throw error; // пробрасывает эту или другую ошибку в следующий catch
*/!*
  }

}).then(function() {
  /* никогда не выполнится */
}).catch(error => { // (**)

  alert(`Неизвестная ошибка: ${error}`);
  // ничего не возвращаем => выполнение продолжается в нормальном режиме

});
```

Затем управление переходит от первого блока `.catch` `(*)`, к следующему `(**)`, вниз по цепочке.

В следующем разделе мы рассмотрим практическое применение повторного пробрасывания.

## Пример обработки fetch ошибок

Давайте улучшим обработку ошибок для примера "загрузка пользователя".

Промис, возвращаемый [fetch](mdn:api/WindowOrWorkerGlobalScope/fetch), считается отклонённым, когда невозможно сделать запрос. Например, удалённый сервер недоступен или неверный URL. Но, если удалённый сервер отвечает с ошибкой 404 или даже 500, тогда ответ считается действительным (корректным).

Что если в строке с `(*)` сервер возвращает не JSON страницу с 500 ошибкой? Что если такого пользователя нет и github возвращает страницу с 404 ошибкой в строке с `(**)`?

```js run
fetch('no-such-user.json') // (*)
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`)) // (**)
  .then(response => response.json())
  .catch(alert); // SyntaxError: Unexpected token < in JSON at position 0
  // ...
```


На данный момент код пытается загрузить ответ как JSON строку, несмотря ни на что и умирает с синтаксической ошибкой. Вы можете сами увидеть это, запустите представленный выше пример, так как файл `no-such-user.json` не существует.

Это не хорошо, потому что ошибка просто проваливается сквозь всю цепочку, без подробностей: что за ошибка и где.

Итак, давайте добавим ещё один шаг: мы должны проверить свойство `response.status`, которое есть в HTTP и если статус не 200, тогда пробросим ошибку.

```js run
class HttpError extends Error { // (1)
  constructor(response) {
    super(`${response.status} for ${response.url}`);
    this.name = 'HttpError';
    this.response = response;
  }
}

function loadJson(url) { // (2)
  return fetch(url)
    .then(response => {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new HttpError(response);
      }
    })
}

loadJson('no-such-user.json') // (3)
  .catch(alert); // HttpError: 404 for .../no-such-user.json
```

1. Мы создали специальный класс для HTTP ошибок, чтобы отличать их от других типов ошибок. Кроме того, новый класс имеет конструктор, который принимает объект `response` и сохраняет его ошибках. Таким образом, код обработки ошибок сможет получить к нему доступ.
2. Затем мы объединили код запроса данных и обработки ошибки в одну функцию, которая получает данные по `url` *и* обрабатывает ответ со статусом 200 как выполнившийся, а любой другой статус, как ошибку. Это удобно, потому что нам часто необходима такая логика.
3. Сейчас `alert` показывает более полезное сообщение.

Самое замечательное в нашем собственном классе для ошибок заключается в том, что мы можем легко проверить его в коде обработки ошибок.

Например, мы можем создать запрос и после, если получим 404 -- попросить пользователя поправить введённую информацию.

Код ниже загружает пользователя с указанным именем из github. Если такого пользователя не существует, то он запрашивает ввести правильное имя:

```js run
function demoGithubUser() {
  let name = prompt("Enter a name?", "iliakan");

  return loadJson(`https://api.github.com/users/${name}`)
    .then(user => {
      alert(`Full name: ${user.name}.`);
      return user;
    })
    .catch(err => {
*!*
      if (err instanceof HttpError && err.response.status == 404) {
*/!*
        alert("Нет такого пользователя, пожалуйста, заполните снова.");
        return demoGithubUser();
      } else {
        throw err; // (*)
      }
    });
}

demoGithubUser();
```

Обратите внимание: в приведённом коде `.catch` перехватывает все ошибки, но "знает как обработать" только `HttpError 404`. В данном примере это означает, что пользователя не существует, в этом случае `.catch` повторно запускает ввод имени.

Для других ошибок, код понятия не имеет, что могло пойти не так. Может быть это программная ошибка или что-то другое. Поэтому просто повторно пробрасывает её в строке с `(*)`.

## Необработанные ошибки

Что произойдёт, если ошибка не будет обработана? Например, после повторного пробрасывания в строке с `(*)` в примере выше.

Или мы просто забыли добавить обработку ошибки в самый конец цепочки, как здесь:

```js untrusted run refresh
new Promise(function() {
  noSuchFunction(); // Ошибка (нет такой функции)
})
  .then(() => {
    // ничего или множество обработчиков промиса
  }); // без .catch в самом конце!
```

В случае ошибки промис становится "отклонённым" и выполнение переходит к ближайшему обработчику ошибок. Но в примере ниже нет никакого обработчика. Поэтому ошибка как-бы "застревает".

На практике, как и при обычных необработанных ошибках это означает, что что-то ужасно пошло не так, скрипт, возможно, умер.

Большинство JavaScript движков отслеживают такие ситуации и генерируют в этом случае глобальную ошибку. Мы можем увидеть это в консоли.

В браузере мы можем поймать такие ошибки, используя событие `unhandledrejection`:

```js run
*!*
window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Whoops! - необработанный объект ошибки
});
*/!*

new Promise(function() {
  throw new Error("Whoops!");
}); // нет обработчика ошибок
```

Это событие является частью [HTML стандарта](https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections).

Если происходит ошибка и она не перехватывается, отсутствует `.catch`, тогда тригерится событие `unhandledrejection` и объект `event` получает информацию об ошибке, поэтому мы можем хоть как-то отреагировать на ошибку.

Обычно такие ошибки неустранимы, поэтому лучше всего - информировать пользователя о проблеме и возможно, отправить информацию об ошибке на сервер.

В не браузерных средах, таких как Node.JS, есть другие похожие способы отслеживания необработанных ошибок.


## Итого

- `.catch` перехватывает все виды отклонённых промисов: будет это вызов `reject()` или ошибка пробросится (throw) в обработчике.
- Необходимо размещать `.catch` там, где мы точно хотим обработать ошибку и знаем, как её обработать. Обработчик должен проанализировать ошибку (помогают пользовательские классы ошибок) или повторно пробросить её, если ничего не знает о ней.
- Это нормально, не использовать `.catch`, если мы не знаем как обработать ошибку (невозможно исправить все ошибки).
- В любом случае нам следует использовать обработчик события `unhandledrejection` (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать об этом пользователя (и, возможно, наш сервер) о них, так что наше приложение никогда "не умрёт".

И наконец, если у нас имеется индикатор загрузки, тогда `.finally` - отличный обработчик окончания загрузки, когда загрузка завершена:

```js run
function demoGithubUser() {
  let name = prompt("Enter a name?", "iliakan");

*!*
  document.body.style.opacity = 0.3; // (1) запускаем индикатор загрузки
*/!*

  return loadJson(`https://api.github.com/users/${name}`)
*!*
    .finally(() => { // (2) останавливаем индикатор загрузки
      document.body.style.opacity = '';
      return new Promise(resolve => setTimeout(resolve, 0)); // (*)
    })
*/!*
    .then(user => {
      alert(`Full name: ${user.name}.`);
      return user;
    })
    .catch(err => {
      if (err instanceof HttpError && err.response.status == 404) {
        alert("Нет такого пользователя, пожалуйста, заполните снова.");
        return demoGithubUser();
      } else {
        throw err;
      }
    });
}

demoGithubUser();
```

Здесь, в строке `(1)`, мы запускаем индикатор загрузки, затемняя документ. Метод не имеет значения, можно использовать любой другой индикатор загрузки.

Когда промис будет выполнен, будет он успешно выполнен или произойдёт ошибка, `finally` сработает в строке `(2)` и остановит индикатор загрузки.

Здесь есть небольшой браузерный трюк в строке с `(*)`, где возвращаем в `finally` промис с нулевым таймаутом. Просто некоторым браузерам (например, Chrome) нужно "немного времени" вне обработчиков промиса, чтобы отрисовать изменения в документе. Таким образом, это гарантирует, что индикатор загрузки визуально остановится, прежде чем управление пойдёт дальше по цепочке.
