# Promise

Представьте, что вы известный певец, которого фанаты постоянно донимают расспросами о предстоящем сингле.

Чтобы получить передышку, вы обещаете разослать его им, когда он будет опубликован. Вы даете фанатам список, в который они могут записаться, чтобы получить новости. Они могут оставить свой e-mail, чтобы когда песня выйдет сразу получить её. И даже больше, если, например, вы передумаете выпускать песню, они также получат уведомление об этом.

Все счастливы! Вы счастливы, потому что вас больше не донимают фанаты, а фанаты - могут больше не беспокоится, что пропустят новый сингл.

Это аналогия из реальной жизни для того, с чем программисты сталкиваются часто:

1. "Певец" - это "создающий" код, который делает что-то, что занимает время. Например, скачивает новый скрипт.
2. "Фанаты" - это "потребляющий" код, который хочет получить результат "создающего" кода, когда он будет готов. Этот результат может быть необходим большому количеству функций.
3. *Promise* (обещание) - это специальный объект в JavaScript, который связывает "создающий" и "потребляющий" коды вместе. В терминах нашей аналогии - это "список подписок". "Создающий" код может выполнятся любое необходимое ему время, чтобы получить обещанный результат, а *обещание* делает результат доступным для всего кода, который подписан на него, когда результат готов.

Аналогия не совсем точна, потому что промисы в JavaScript более сложные, чем простой список подписки: они обладают дополнительными функциями и ограничениями. Но для начала она хорошо подходит.

Синтаксис создания `Promise`:

```js
let promise = new Promise(function(resolve, reject) {
  // исполнитель ("создающий код", "певец")
});
```

Функция, которая передаётся в конструкцию  `new Promise` называется *исполнитель*. Когда `Promise` создан, функция исполнитель запускается автоматически. Она содержит "создающий" код, который в конечном итоге должен создать результат. В терминах аналогии: *исполнитель* - это "певец".

Объект `Promise`, полученный в результате выполнения конструктора, имеет внутренние свойства:

- `state` (состояние) — вначале `pending` ("ожидание"), потом может измениться на `fulfilled` («выполнено успешно») or `rejected` («выполнено с ошибкой»),
- `result` (результат) — имеет произвольное значение, по вашему выбору, вначале `undefined`.

Когда исполнитель заканчивает задачу, должна быть вызвана одна из функций, переданных в него как аргумент:

- `resolve(value)` — чтобы сообщить, что работа выполнена успешно:
    - устанавливает в `state` значение `"fulfilled"`,
    - устанавливает в  `result` значение `value`.
- `reject(error)` — чтобы сообщить, что произошла ошибка:
    - устанавливает в `state` значение `"rejected"`,
    - устанавливает в `result` значение `error`.

![](promise-resolve-reject.png)

Позже мы рассмотрим, как "фанаты" узнают об этих изменениях.

Ниже пример с конструктором `Promise` и простого исполнителя с "создающим" кодом (`setTimeout`):

```js run
let promise = new Promise(function(resolve, reject) {
  // функция выполнится автоматически, когда Promise будет создан

  // через 1 секунду появится сигнал, что задача выполнена с результатом "done"
  setTimeout(() => *!*resolve("done")*/!*, 1000);
});
```

Мы можем наблюдать две вещи, запустив код выше:

1. Исполнитель вызывается автоматически и сразу (с помощью `new Promise`).
2. Исполнитель получает два аргумента: `resolve` и `reject` — эти функции предопределены в JavaScript. Таким образом нам не нужно их создавать, а вместо этого мы должны написать функцию-исполнитель таким образом, чтобы вызвать их в конце.

Через одну секунду "обработки" исполнитель вызовет `resolve("done")`, чтобы передать результат:

![](promise-resolve-1.png)

Это был пример успешно выполненной задачи, "выполненный успешно" `Promise`.

А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:

```js
let promise = new Promise(function(resolve, reject) {
  // через секунду будет сообщено, что задача выполнена с ошибкой
  setTimeout(() => *!*reject(new Error("Whoops!"))*/!*, 1000);
});
```

![](promise-reject-1.png)

Суммируем, то что мы пока узнали: исполнитель выполняет задачу (что-то что занимает время, обычно) и после этого вызывает `resolve` или `reject`, чтобы изменить состояние соответствующего `Promise`.

`Promise` независимо от того, как он был завершен (с ошибкой или без) называется "решенный", в отличии от "ожидающего" `Promise`.

````smart header="Может быть что-то одно, либо результат, либо ошибка"
Исполнитель должен вызвать что-то одно: `resolve` или `reject`. Состояние промиса может быть изменено только один раз.

Все последующие вызовы `resolve` и `reject` будут проигнорированы:

```js
let promise = new Promise(function(resolve, reject) {
  resolve("done");

  reject(new Error("…")); // игнорируется
  setTimeout(() => resolve("…")); // игнорируется
});
```

Идея в том, что задача выполненная исполнителем может иметь только что-то одно: результат или ошибку.

Также, `resolve`/`reject` ожидают только один аргумент (или ни одного), а все дополнительные аргументы будут проигнорированы.
````

```smart header="`Reject` с объектом `Error`"
В случаях, когда что-то пошло неправильно, `reject` может быть вызван с любым типом аргумента (как и `resolve`). Рекомендуется использовать объект `Error` (или унаследованный от него объект). Обоснование для этого скоро станет очевидным.
```

````smart header="Мгновенный вызов `resolve`/`reject`"
Обычно, исполнитель делает что-то асинхронное и после этого вызывает `resolve`/`reject`  через какое-то время, но это не обязательно. `resolve` или `reject` могут быть вызваны сразу, как в примере:

```js
let promise = new Promise(function(resolve, reject) {
  // задача не требующая времени
  resolve(123); // мгновенно присвоит в результат: 123
});
```

Это может случится, когда задача началась, но в процессе её выполнения стало понятно, что всё уже выполнено.

Всё в порядке, мы сразу получим успешно завершенный `Promise`, в этом нет чего-то неправильного.
````

```smart header="Свойства `state` и `result` - внутренние"
Свойства `state` и `result` - это внутренние свойства объекта `Promise` и мы не имеем к ним прямого доступа из "потребляющего" кода. Для этого следует использовать методы `.then`/`.catch`/`.finally`, про них речь пойдет дальше.
```

## Потребители: then, catch, finally

Объект `Promise` служит связующем звеном между исполнителем ("создающим" кодом или "певцом") и функциями-потребителями ("фанатами"), которые получат, либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов `.then`, `.catch` и `.finally`.

### then (после)

Наиболее важный и фундаментальный метод - `.then`.

Синтаксис:

```js
promise.then(
  function(result) { *!*/* обработает успешное выполнение исполнителя */*/!* },
  function(error) { *!*/* обработает ошибку */*/!* }
);
```

Первый аргумент метода `.then` - функция, которая

1. выполняется, когда `Promise` переходит в состояние `fulfilled`
2. получает результат.

Второй аргумент `.then`  - функция, которая:

1. выполняется, когда `Promise` переходит в состояние `rejected`
2. получает ошибку.

Например, ниже реакции на успешно завершенный промис:

```js run
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done!"), 1000);
});

// resolve запустит первую функцию, переданную в .then
promise.then(
*!*
  result => alert(result), // покажет "done!" через секунду
*/!*
  error => alert(error) // не будет запущена
);
```

Первая функция была выполнена.

И в случае ошибки -- вторая:

```js run
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

// reject запустит вторую функцию, переданную в .then
promise.then(
  result => alert(result), // не будет запущена
*!*
  error => alert(error) // покажет "Error: Whoops!" через секунду
*/!*
);
```

Если нам важен только результат успешного выполнения задачи, тогда в `then` может быть передана только одна функция:

```js run
let promise = new Promise(resolve => {
  setTimeout(() => resolve("done!"), 1000);
});

*!*
promise.then(alert); // покажет "done!" через секунду
*/!*
```

### catch (поймать)

Если нам важно только обработать ошибку, тогда можно передать `null` в качестве первого аргумента: `.then(null, errorHandlingFunction)`. Или можно использовать метод `.catch(errorHandlingFunction)`, который сделает тоже самое:

```js run
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

*!*
// .catch(f) это тоже самое promise.then(null, f)
promise.catch(alert); // покажет "Error: Whoops!" через секунду
*/!*
```

Вызов `.catch(f)` это полный аналог `.then(null, f)`, просто это более короткая запись.

### finally (в конце)

В промисах `finally` работает также как в обычном `try {...} catch {...}`.

Вызов `.finally(f)` это тоже самое, что передать в `.then(f, f)`, в том смысле, что "потребляющий" код выполниться в любом случае, когда промис станет решённым: успешно или с ошибкой.

`finally` хорошо подходит для очистки, например остановки индикаторов загрузки, поскольку они будут не нужны в независимости от результата.

Например:

```js
new Promise((resolve, reject) => {
  /* сделать что-то, что займет время, и после вызвать resolve/reject */
})
*!*
  // выполнится когда промис завершиться, независимо успешно или нет
  .finally(() => stop loading indicator)
*/!*
  .then(result => show result, err => show error)
```

Это не совсем псевдоним, как можно подумать. Существует несколько важных отличий:

1. Функция вызываемая из `finally` не имеет аргументов. В `finally` неизвестно, как был завершен `Promise`. Это правильно, потому что задача здесь заключается в выполнении "общих" процедур завершения задачи.
2. `Finally` пропустит результат или ошибку к следующим обработчикам.

    Например, здесь результат проходит через `finally` к `then`:
    ```js run
    new Promise((resolve, reject) => {
      setTimeout(() => resolve("result"), 2000)
    })
      .finally(() => alert("Promise ready"))
      .then(result => alert(result)); // <-- .then обработает результат
    ```

    А здесь ошибка из промиса, пройдет через `finally` к `catch`:

    ```js run
    new Promise((resolve, reject) => {
      throw new Error("error");
    })
      .finally(() => alert("Promise ready"))
      .catch(err => alert(err));  // <-- .catch обработает объект ошибки
    ```  

    Это очень удобно, потому что `finaly` не предназначен для обработки результата `Promise`. Он просто пропускает их через себя.

    Мы поговорим о создании цепочек промисов и передаче результатов между обработчиками в следующей главе.

3. Последнее, но не менее значимое, `.finally(f)` более удобный синтаксис, чем у`.then(f, f)`: не надо дублировать функции.

````smart header="На завершенных промисах обработчики запускаются сразу"
Если промис в состоянии ожидания, обработчики в `.then/catch/finally` будут ждать окончания. Однако, если промис уже решен, тогда они выполнятся сразу:

```js run
// мгновенный перевод промиса в состояние решён
let promise = new Promise(resolve => resolve("done!"));

promise.then(alert); // done! (появляется прямо сейчас)
```
Хорошо то, что обработчик `.then` гарантированно запустится в любом случае: если `Promise` занимает время или выполняется мгновенно.
````

Дальше рассмотрим несколько практических примеров того, как `Promise` может помочь написанию асинхронного кода.

## Пример: loadScript

У нас есть функция `loadScript` для загрузки скрипта из предыдущей главы.

Давайте вспомним, как выглядел вариант с callback-функцией:

```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Script load error for ${src}`));

  document.head.append(script);
}
```

Теперь перепишем её используя `Promise`.

Новая функция `loadScript` не требует callback. Вместо этого она будет создавать и возвращать объект `Promise`, который будет переходить в состояние решен, когда загрузка закончится. Внешний код может добавлять обработчики (функции-подписчиков) используя для этого метод `.then`:

```js run
function loadScript(src) {  
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Script load error for ${src}`));

    document.head.append(script);
  });
}
```

Применение:

```js run
let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
  script => alert(`${script.src} is loaded!`),
  error => alert(`Error: ${error.message}`)
);

promise.then(script => alert('One more handler to do something else!'));
```

Сразу видны преимущество над подходом с callback-функцией:


| Promises | Callbacks |
|----------|-----------|
| Промисы позволяют делать вещи в естественном порядке. Сначала запускается `loadScript(script)`, и затем (`.then`) мы пишем, что делать с результатом. | У нас должна быть `callback-функция` на момент вызова `loadScript(script, callback)`. Другими словами, нам нужно знать что делать с результатом, *перед тем*, как вызвать `loadScript`. |
| Мы можем вызывать `.then` у `Promise` столько раз, сколько захотим. Каждый раз, мы добавляем нового "фаната", новую функцию-подписчика, в "список подписок". Больше об этом в следующей главе: [](info:promise-chaining). | Callback-функция может быть только одна. |

Таким образом, промисы позволяют улучшить порядок кода и дают нам гибкость. Но это ещё не всё. Мы увидим это в следующих главах.
